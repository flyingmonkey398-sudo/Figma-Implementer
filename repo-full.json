{
  "name": "Figma-Plugin-YY-Assistant",
  "type": "folder",
  "children": [
    {
      "name": ".DS_Store",
      "type": "file",
      "content": null
    },
    {
      "name": ".gitignore",
      "type": "file",
      "content": null
    },
    {
      "name": "main-implement.js",
      "type": "file",
      "content": "(() => {\n  const uiLog = (text) => {\n    try {\n      figma.ui.postMessage({ type: \"log\", text });\n    } catch (_) {\n    }\n  };\n  const log = (...a) => {\n    console.log(\"[YY-MakeChanges]\", ...a);\n    uiLog(a.map(String).join(\" \"));\n  };\n  const ok = (m) => {\n    figma.notify(`\\u2705 ${m}`);\n    uiLog(`\\u2705 ${m}`);\n  };\n  const err = (m) => {\n    figma.notify(`\\u26A0\\uFE0F ${m}`);\n    uiLog(`\\u26A0\\uFE0F ${m}`);\n  };\n  const warn = (msg) => console.warn(`\\u26A0\\uFE0F ${msg}`);\n  figma.showUI(\n    `<html><body style=\"margin:8px;font:12px ui-monospace,monospace\">\n    <div id=out style=\"white-space:pre;max-width:460px;margin-bottom:6px\"></div>\n    <label for=txt style=\"display:block;margin-bottom:4px;font-weight:600;\">Insert JSON:</label>\n    <textarea id=txt rows=8 placeholder='{\"meta\": {...}, \"variables\": {...}, \"nodes\": [...] }'\n      style=\"width:460px;max-width:460px;font:12px ui-monospace,monospace;white-space:pre\"></textarea><br/>\n    <div style=\"margin-top:6px;display:flex;gap:6px\">\n      <button id=apply>Apply JSON</button>\n      <button id=retie>Re-tie page to variables</button>\n    </div>\n\n    <script>\n      const out = document.getElementById('out');\n      const txt = document.getElementById('txt');\n      const btnApply = document.getElementById('apply');\n      const btnRetie = document.getElementById('retie');\n      const log = (m) => out.textContent += (m + \"\\\\n\");\n      window.onmessage = (e) => { const m = e.data.pluginMessage; if (m && m.type === 'log') log(m.text); };\n\n      btnApply.onclick = () => parent.postMessage({ pluginMessage:{ type:'apply-json', text: txt.value } }, '*');\n      btnRetie.onclick  = () => parent.postMessage({ pluginMessage:{ type:'retie' } }, '*');\n    <\\/script>\n  </body></html>`,\n    { width: 500, height: 360 }\n  );\n  figma.ui.onmessage = async (msg) => {\n    var _a;\n    if ((msg == null ? void 0 : msg.type) === \"retie\") {\n      await retiePageToVariables();\n      return;\n    }\n    if ((msg == null ? void 0 : msg.type) !== \"apply-json\") return;\n    try {\n      const raw = msg.text;\n      const parsed = typeof raw === \"string\" ? JSON.parse(raw) : raw;\n      const jsonfile = parseLoadedFile(parsed);\n      applyMeta(jsonfile.meta);\n      await applyVariables(jsonfile.variables);\n      await applyNodes(jsonfile.nodes);\n      ok(\"Changes applied\");\n    } catch (e) {\n      err(\"apply-json failed: \" + String((_a = e == null ? void 0 : e.message) != null ? _a : e));\n    }\n  };\n  function parseLoadedFile(obj) {\n    if (!obj || typeof obj !== \"object\") throw new Error(\"JSON must be an object\");\n    return {\n      schema: obj[\"$schema\"] || null,\n      meta: obj.meta || {},\n      variables: obj.variables || { collectionsCount: 0, collections: [] },\n      nodes: obj.nodes || null\n    };\n  }\n  function applyMeta(meta = {}) {\n    try {\n      if (meta.fileName) figma.root.setPluginData(\"yy_desiredFileName\", String(meta.fileName));\n      if (meta.scanId) figma.root.setPluginData(\"yy_scanId\", String(meta.scanId));\n      if (meta.pageName) figma.root.setPluginData(\"yy_pageName\", String(meta.pageName));\n      if (meta.author) figma.root.setPluginData(\"yy_author\", String(meta.author));\n      if (meta.version) figma.root.setPluginData(\"yy_version\", String(meta.version));\n      try {\n        const NS = \"yy\";\n        Object.entries(meta).forEach(([k, v]) => {\n          if (v != null) figma.root.setSharedPluginData(NS, k, String(v));\n        });\n      } catch (e) {\n      }\n      const desired = figma.root.getPluginData(\"yy_desiredFileName\");\n      if (desired) ok(`Please rename this file to: ${desired} (plugins can\\u2019t rename files)`);\n      log(\"Meta saved: \" + JSON.stringify({ fileName: meta.fileName, scanId: meta.scanId, pageName: meta.pageName, author: meta.author, version: meta.version }));\n    } catch (e) {\n      err(\"applyMeta: \" + String(e));\n    }\n  }\n  async function applyVariables(variables = { collections: [] }) {\n    var _a;\n    try {\n      if (!figma.variables) {\n        log(\"Variable API unavailable\");\n        return;\n      }\n      const cols = Array.isArray(variables == null ? void 0 : variables.collections) ? variables.collections : [];\n      if (!cols.length) {\n        log(\"No variable collections to apply\");\n        return;\n      }\n      const TYPE = {\n        COLOR: \"COLOR\",\n        FLOAT: \"FLOAT\",\n        STRING: \"STRING\",\n        BOOLEAN: \"BOOLEAN\",\n        NUMBER: \"FLOAT\"\n      };\n      const localCollections = await figma.variables.getLocalVariableCollectionsAsync();\n      const collectionByName = new Map(localCollections.map((c) => [c.name, c]));\n      for (const c of cols) {\n        const name = String((c == null ? void 0 : c.name) || \"\").trim();\n        if (!name) {\n          log(\"Skip unnamed collection\");\n          continue;\n        }\n        let collection = collectionByName.get(name);\n        if (!collection) {\n          collection = figma.variables.createVariableCollection(name);\n          collectionByName.set(name, collection);\n          log(`Created collection: \"${name}\" (${collection.id})`);\n        } else {\n          log(`Collection exists: \"${name}\"`);\n        }\n        const wantModes = (Array.isArray(c == null ? void 0 : c.modes) ? c.modes : []).map((m) => String((m == null ? void 0 : m.name) || \"\").trim()).filter(Boolean);\n        if (wantModes.length) {\n          if (collection.modes.length === 1 && collection.modes[0].name !== wantModes[0]) {\n            collection.renameMode(collection.modes[0].modeId, wantModes[0]);\n            log(`  \\u2022 renamed default mode \\u2192 ${wantModes[0]}`);\n          }\n          for (const m of wantModes) {\n            if (!collection.modes.find((x) => x.name === m)) {\n              collection.addMode(m);\n              log(`  \\u2022 added mode: ${m}`);\n            }\n          }\n        } else if (!collection.modes.length) {\n          collection.addMode(\"Base\");\n        }\n        const modeIdByName = new Map(collection.modes.map((m) => [m.name, m.modeId]));\n        const wantVars = Array.isArray(c == null ? void 0 : c.variables) ? c.variables : [];\n        if (!wantVars.length) {\n          log(`  (no variables in \"${name}\")`);\n          continue;\n        }\n        const localVars = (await figma.variables.getLocalVariablesAsync()).filter((v) => v.variableCollectionId === collection.id);\n        const varByName = new Map(localVars.map((v) => [v.name, v]));\n        for (const v of wantVars) {\n          const vName = String((v == null ? void 0 : v.name) || \"\").trim();\n          if (!vName) {\n            log(\"  - skip unnamed variable\");\n            continue;\n          }\n          const vType = (_a = TYPE[String((v == null ? void 0 : v.type) || \"\").toUpperCase()]) != null ? _a : \"STRING\";\n          const valuesByMode = (v == null ? void 0 : v.valuesByMode) && typeof v.valuesByMode === \"object\" ? v.valuesByMode : {};\n          let variable = varByName.get(vName);\n          if (!variable) {\n            variable = figma.variables.createVariable(vName, collection.id, vType);\n            varByName.set(vName, variable);\n            log(`  + var: ${vName} (${vType})`);\n          } else if (variable.resolvedType !== vType) {\n            log(`  ! type mismatch for ${vName} (have ${variable.resolvedType}, want ${vType}) \\u2014 recreating`);\n            variable.remove();\n            variable = figma.variables.createVariable(vName, collection.id, vType);\n            varByName.set(vName, variable);\n          } else {\n            log(`  = var: ${vName}`);\n          }\n          for (const [modeName, raw] of Object.entries(valuesByMode)) {\n            const modeId = modeIdByName.get(modeName);\n            if (!modeId) {\n              log(`    \\u2022 mode \"${modeName}\" not found in \"${name}\"`);\n              continue;\n            }\n            try {\n              let val = raw;\n              if (vType === \"COLOR\") {\n                const { r, g, b, a } = hexToRgb01(String(raw).trim());\n                val = { r, g, b, a };\n              } else if (vType === \"FLOAT\") {\n                val = Number(raw);\n              } else if (vType === \"BOOLEAN\") {\n                val = Boolean(raw);\n              } else {\n                val = String(raw);\n              }\n              variable.setValueForMode(modeId, val);\n              log(`    \\u2022 set ${vName} @ ${modeName}`);\n            } catch (e) {\n              err(`    set ${vName} @ ${modeName}: ${String(e)}`);\n            }\n          }\n        }\n      }\n    } catch (e) {\n      err(\"applyVariables: \" + String(e));\n    }\n  }\n  function hexToRgb01(hex) {\n    const h = hex.replace(\"#\", \"\").trim();\n    let r = 0, g = 0, b = 0, a = 1;\n    if (h.length === 3) {\n      r = parseInt(h[0] + h[0], 16);\n      g = parseInt(h[1] + h[1], 16);\n      b = parseInt(h[2] + h[2], 16);\n    } else if (h.length === 6) {\n      r = parseInt(h.slice(0, 2), 16);\n      g = parseInt(h.slice(2, 4), 16);\n      b = parseInt(h.slice(4, 6), 16);\n    } else if (h.length === 8) {\n      r = parseInt(h.slice(0, 2), 16);\n      g = parseInt(h.slice(2, 4), 16);\n      b = parseInt(h.slice(4, 6), 16);\n      a = parseInt(h.slice(6, 8), 16) / 255;\n    }\n    return { r: r / 255, g: g / 255, b: b / 255, a };\n  }\n  async function applyNodes(nodes) {\n    let updatedCount = 0;\n    if (!nodes) return log(\"No changes found\");\n    const arr = Array.isArray(nodes) ? nodes : [nodes];\n    const nodeMap = /* @__PURE__ */ new Map();\n    const componentMap = /* @__PURE__ */ new Map();\n    async function createNode(spec, parent) {\n      var _a, _b, _c, _d;\n      const t = ((spec == null ? void 0 : spec.type) || (spec == null ? void 0 : spec.kind) || \"\").toUpperCase();\n      if (spec.id) {\n        const node2 = figma.getNodeById(spec.id);\n        if (node2 && node2.type === \"COMPONENT\" && !node2.mainComponent) {\n          log(`\\u26D4 Skipping component master: ${node2.name}`);\n          return null;\n        }\n      }\n      let node = null;\n      try {\n        switch (t) {\n          // ──────────────────────────── FRAME UPDATE ────────────────────────────\n          case \"FRAME\":\n          case \"FRAME-SNAPSHOT\": {\n            const id = spec == null ? void 0 : spec.id;\n            if (!id) {\n              log(\"frame-snapshot missing id\");\n              break;\n            }\n            const existing = figma.getNodeById(id);\n            if (existing.type !== \"FRAME\" && existing.type !== \"INSTANCE\") {\n              log(`Node ${id} not a FRAME or INSTANCE \\u2014 skipped`);\n              break;\n            }\n            const f = existing;\n            const p = spec.absPos, s = spec.size;\n            if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) {\n              f.x = p.x;\n              f.y = p.y;\n              log(`pos \\u2192 ${p.x},${p.y}`);\n            }\n            if (s && Number.isFinite(s.w) && Number.isFinite(s.h)) {\n              f.resize(s.w, s.h);\n              log(`size \\u2192 ${s.w}\\xD7${s.h}`);\n            }\n            ok(`Frame updated: ${f.name}`);\n            if (Array.isArray(spec.children)) {\n              for (const child of spec.children) {\n                await createNode(child, f);\n              }\n            }\n            break;\n          }\n          // ──────────────────────────── INSTANCE UPDATE ────────────────────────────\n          // -------------------- Instance Update (for swatch palettes) --------------------\n          case \"INSTANCE-UPDATE\": {\n            const name = String((spec == null ? void 0 : spec.name) || \"\").trim();\n            if (!name) {\n              log(\"Instance-update missing name\");\n              break;\n            }\n            const inst = figma.currentPage.findOne(\n              (n) => n.name === name && (n.type === \"INSTANCE\" || n.type === \"FRAME\")\n            );\n            if (!inst) {\n              warn(`Instance \"${name}\" not found`);\n              break;\n            }\n            if (inst.type === \"COMPONENT\") {\n              log(`\\u23ED\\uFE0F Skipping master component: ${name}`);\n              break;\n            }\n            let colorRect = null;\n            try {\n              colorRect = inst.findOne((n) => n.name === \"ColorBox\");\n              if (colorRect) {\n                if (spec.Hex) {\n                  const { r, g, b, a } = hexToRgb01(spec.Hex);\n                  colorRect.fills = [{ type: \"SOLID\", color: { r, g, b }, opacity: a }];\n                  log(`\\u{1F3A8} Updated fill color for ${name}`);\n                }\n                if (spec.variableAlias) {\n                  try {\n                    const variable = figma.variables.getVariableById(spec.variableAlias);\n                    if (variable) {\n                      colorRect.boundVariables = {\n                        fills: { type: \"VARIABLE_ALIAS\", id: variable.id }\n                      };\n                      log(`\\u2705 Bound ${name} fill to variable: ${variable.name}`);\n                    } else {\n                      warn(`\\u26A0\\uFE0F Variable not found: ${spec.variableAlias}`);\n                    }\n                  } catch (e) {\n                    warn(`\\u26A0\\uFE0F Failed to bind variable for ${name}: ${String(e)}`);\n                  }\n                }\n              } else {\n                warn(`No \"ColorBox\" found inside ${name}`);\n              }\n            } catch (e) {\n              err(`Failed to recolor ${name}: ${String(e)}`);\n            }\n            try {\n              const label = inst.findOne((n) => n.name === \"Label\");\n              if (label && spec.Label) {\n                await figma.loadFontAsync(label.fontName);\n                label.characters = spec.Label;\n              }\n              const hexText = inst.findOne((n) => n.name === \"Hex\");\n              if (hexText && spec.Hex) {\n                await figma.loadFontAsync(hexText.fontName);\n                hexText.characters = spec.Hex;\n              }\n              log(`\\u{1F4DD} Updated text for ${name}`);\n            } catch (e) {\n              warn(`\\u26A0\\uFE0F Text update failed in ${name}: ${String(e)}`);\n            }\n            updatedCount++;\n            break;\n          }\n          // ──────────────────────────── INSTANCE CREATION ────────────────────────────\n          case \"INSTANCE\": {\n            try {\n              const componentId = String((spec == null ? void 0 : spec.componentId) || \"\").trim();\n              if (!componentId) {\n                log(\"Instance missing componentId\");\n                break;\n              }\n              const comp = figma.getNodeById(componentId);\n              if (!comp) {\n                log(`Component not found for id: ${componentId}`);\n                break;\n              }\n              const inst = comp.createInstance();\n              if (spec.name) inst.name = spec.name;\n              if (spec.absPos) {\n                inst.x = spec.absPos.x || 0;\n                inst.y = spec.absPos.y || 0;\n              }\n              if (spec.size) inst.resize(spec.size.w || inst.width, spec.size.h || inst.height);\n              if (spec.autoLayout) {\n                const f = inst;\n                f.layoutMode = spec.autoLayout.direction === \"VERTICAL\" ? \"VERTICAL\" : \"HORIZONTAL\";\n                f.itemSpacing = (_a = spec.autoLayout.spacing) != null ? _a : 8;\n                f.paddingLeft = f.paddingRight = f.paddingTop = f.paddingBottom = (_b = spec.autoLayout.padding) != null ? _b : 0;\n              }\n              figma.currentPage.appendChild(inst);\n              ok(`Created instance: ${inst.name}`);\n            } catch (e) {\n              err(`createInstance: ${String(e)}`);\n            }\n            break;\n          }\n          // ──────────────────────────── UNKNOWN / UNSUPPORTED ────────────────────────────\n          default:\n            err(`Unknown node type: ${t} \\u2014 skipped (no fallback creation)`);\n            break;\n        }\n        if (node && spec.name) node.name = spec.name;\n        if (node && spec.size) node.resize(spec.size.w || node.width, spec.size.h || node.height);\n        if (node && spec.absPos) {\n          node.x = spec.absPos.x || 0;\n          node.y = spec.absPos.y || 0;\n        }\n        if (node && spec.autoLayout) {\n          const f = node;\n          f.layoutMode = spec.autoLayout.direction === \"VERTICAL\" ? \"VERTICAL\" : \"HORIZONTAL\";\n          f.itemSpacing = (_c = spec.autoLayout.spacing) != null ? _c : 8;\n          f.paddingLeft = f.paddingRight = f.paddingTop = f.paddingBottom = (_d = spec.autoLayout.padding) != null ? _d : 0;\n        }\n        if (node && spec.fill) {\n          const { r, g, b, a } = hexToRgb01(spec.fill);\n          node.fills = [{ type: \"SOLID\", color: { r, g, b }, opacity: a }];\n        }\n        if (node && Array.isArray(spec.children)) {\n          for (const child of spec.children) await createNode(child, node);\n        }\n        if (node && spec.id) nodeMap.set(spec.id, node);\n        if (node && t === \"COMPONENT\" && spec.id) componentMap.set(spec.id, node);\n        if (node) ok(`Created or updated ${t}: ${spec.name || \"(unnamed)\"}`);\n        return node;\n      } catch (e) {\n        err(`createNode(${(spec == null ? void 0 : spec.name) || t}): ${String(e)}`);\n        return null;\n      }\n    }\n    for (const spec of arr) {\n      if (spec.id) {\n        const nodeById = figma.getNodeById(spec.id);\n        if (nodeById && nodeById.type === \"COMPONENT\" && !nodeById.mainComponent) {\n          log(`\\u26D4 Skipping main component for id ${spec.id}`);\n          continue;\n        }\n        if (nodeById && (nodeById.type === \"INSTANCE\" || nodeById.type === \"FRAME\")) {\n          log(`Updating existing instance/frame by ID: ${nodeById.name}`);\n          if (Array.isArray(spec.children)) {\n            for (const c of spec.children) await createNode(c, nodeById);\n          }\n          continue;\n        }\n      }\n      const target = figma.currentPage.findOne(\n        (n) => n.name === spec.name && (n.type === \"INSTANCE\" || n.type === \"FRAME\")\n      );\n      if (target) {\n        log(`Updating existing node by name: ${target.name}`);\n        if (Array.isArray(spec.children)) {\n          for (const c of spec.children) await createNode(c, target);\n        }\n        continue;\n      }\n      await createNode(spec, figma.currentPage);\n    }\n    ok(`Created or updated ${nodeMap.size} nodes total`);\n  }\n  async function retiePageToVariables() {\n    if (!figma.variables) {\n      log(\"Variables API unavailable\");\n      return;\n    }\n    const collections = await figma.variables.getLocalVariableCollectionsAsync();\n    let vars = await figma.variables.getLocalVariablesAsync();\n    if (!Array.isArray(vars)) vars = [];\n    if (vars.length === 0) {\n      for (const c of collections) {\n        try {\n          const got = await figma.variables.getVariablesInCollectionAsync(c.id);\n          if (Array.isArray(got) && got.length) vars.push(...got);\n        } catch (e) {\n          log(`retie: getVariablesInCollectionAsync failed for \"${c.name}\": ${String(e)}`);\n        }\n      }\n    }\n    log(`retie: found ${collections.length} collections, ${vars.length} variables`);\n    if (!collections.length || !vars.length) {\n      ok(\"Re-tied 0 properties on this page\");\n      return;\n    }\n    const varById = new Map(vars.map((v) => [v.id, v]));\n    const colorIdx = /* @__PURE__ */ new Map();\n    const numIdx = /* @__PURE__ */ new Map();\n    const strIdx = /* @__PURE__ */ new Map();\n    const round255 = (x) => Math.round((x != null ? x : 1) * 255);\n    const keyRGBA = (r, g, b, a) => `${round255(r)},${round255(g)},${round255(b)},${round255(a != null ? a : 1)}`;\n    const getVal = (v, modeId) => {\n      try {\n        if (typeof v.getValueForMode === \"function\") return v.getValueForMode(modeId);\n        if (typeof v.getValueForModeId === \"function\") return v.getValueForModeId(modeId);\n      } catch (_) {\n      }\n      if (v.valuesByMode && typeof v.valuesByMode === \"object\") {\n        const val = v.valuesByMode[modeId];\n        if (val !== void 0) return val;\n      }\n      return void 0;\n    };\n    for (const v of vars) {\n      const col = collections.find((c) => c.id === v.variableCollectionId);\n      if (!col) continue;\n      for (const m of col.modes) {\n        const val = getVal(v, m.modeId);\n        if (val == null) continue;\n        if (v.resolvedType === \"COLOR\" && typeof val === \"object\" && \"r\" in val) {\n          const { r, g, b, a } = val;\n          colorIdx.set(keyRGBA(r, g, b, a), { id: v.id, name: v.name });\n        } else if (v.resolvedType === \"FLOAT\") {\n          const n = Number(val);\n          if (Number.isFinite(n)) numIdx.set(n, { id: v.id, name: v.name });\n        } else if (v.resolvedType === \"STRING\") {\n          strIdx.set(String(val), { id: v.id, name: v.name });\n        }\n      }\n    }\n    log(`indexed ${colorIdx.size} colors, ${numIdx.size} numbers, ${strIdx.size} strings`);\n    const solidRGBA = (p) => {\n      const a = typeof p.opacity === \"number\" ? p.opacity : 1;\n      return { r: p.color.r, g: p.color.g, b: p.color.b, a };\n    };\n    const nodes = figma.currentPage.findAll();\n    let bound = 0;\n    function bindPaintColor(node, prop, varId) {\n      const variable = varById.get(varId);\n      if (!variable) {\n        log(`WARN paint: missing var ${varId}`);\n        return false;\n      }\n      const paints = node[prop];\n      if (!Array.isArray(paints) || paints.length === 0) return false;\n      const p0 = paints[0];\n      if (p0.type !== \"SOLID\") return false;\n      const newPaint = Object.assign({}, p0);\n      const existingBV = p0.boundVariables || {};\n      const nextBV = Object.assign({}, existingBV, {\n        // ✅ REQUIRED SHAPE\n        color: { type: \"VARIABLE_ALIAS\", id: variable.id }\n      });\n      newPaint.boundVariables = nextBV;\n      const next = paints.slice();\n      next[0] = newPaint;\n      try {\n        node[prop] = next;\n        return true;\n      } catch (e) {\n        log(`bind ${prop} color failed: ${String(e)}`);\n        return false;\n      }\n    }\n    const bind = (node, prop, varId) => {\n      const variable = varById.get(varId);\n      if (!variable) return;\n      try {\n        node.setBoundVariable(prop, variable);\n        bound++;\n      } catch (e) {\n        log(`bind ${prop} failed: ${String(e)}`);\n      }\n    };\n    for (const node of nodes) {\n      if (\"fills\" in node) {\n        const fs = node.fills;\n        if (Array.isArray(fs) && fs.length && fs[0].type === \"SOLID\") {\n          const { r, g, b, a } = solidRGBA(fs[0]);\n          const m = colorIdx.get(keyRGBA(r, g, b, a));\n          if (m && bindPaintColor(node, \"fills\", m.id)) {\n            bound++;\n            log(`bind fills \\u2192 ${m.name}`);\n          }\n        }\n      }\n      if (\"strokes\" in node) {\n        const st = node.strokes;\n        if (Array.isArray(st) && st.length && st[0].type === \"SOLID\") {\n          const { r, g, b, a } = solidRGBA(st[0]);\n          const m = colorIdx.get(keyRGBA(r, g, b, a));\n          if (m && bindPaintColor(node, \"strokes\", m.id)) {\n            bound++;\n            log(`bind strokes \\u2192 ${m.name}`);\n          }\n        }\n      }\n      if (node.type === \"TEXT\") {\n        const t = node;\n        if (typeof t.fontSize === \"number\") {\n          const m = numIdx.get(t.fontSize);\n          if (m) {\n            bind(t, \"fontSize\", m.id);\n            log(`bind fontSize \\u2192 ${m.name}`);\n          }\n        }\n        const lh = t.lineHeight;\n        if (lh && typeof lh === \"object\" && lh.unit === \"PIXELS\" && typeof lh.value === \"number\") {\n          const m = numIdx.get(lh.value);\n          if (m) {\n            bind(t, \"lineHeight\", m.id);\n            log(`bind lineHeight \\u2192 ${m.name}`);\n          }\n        }\n        const tf = t.fills;\n        if (Array.isArray(t.fills) && t.fills.length && t.fills[0].type === \"SOLID\") {\n          const { r, g, b, a } = solidRGBA(t.fills[0]);\n          const m = colorIdx.get(keyRGBA(r, g, b, a));\n          if (m && bindPaintColor(t, \"fills\", m.id)) {\n            bound++;\n            log(`bind text fill \\u2192 ${m.name}`);\n          }\n        }\n      }\n      const n = node;\n      const numericProps = [\"itemSpacing\", \"paddingLeft\", \"paddingRight\", \"paddingTop\", \"paddingBottom\", \"cornerRadius\", \"strokeWeight\"];\n      for (const prop of numericProps) {\n        if (typeof n[prop] === \"number\") {\n          const m = numIdx.get(n[prop]);\n          if (m) {\n            bind(node, prop, m.id);\n            log(`bind ${prop} \\u2192 ${m.name}`);\n          }\n        }\n      }\n    }\n    ok(`Re-tied ${bound} properties on this page`);\n  }\n  log(\"YY Make Changes ready\");\n  figma.notify(\"YY Make Changes plugin ready\");\n})();\n"
    },
    {
      "name": "main-implement.ts",
      "type": "file",
      "content": "// main-implement.js\n\nconst uiLog = (text: string) => { try { figma.ui.postMessage({ type: \"log\", text }); } catch (_) { /* ignored */ } };\nconst log = (...a) => { console.log(\"[YY-MakeChanges]\", ...a); uiLog(a.map(String).join(\" \")); };\nconst ok = (m) => { figma.notify(`✅ ${m}`); uiLog(`✅ ${m}`); };\nconst err = (m) => { figma.notify(`⚠️ ${m}`); uiLog(`⚠️ ${m}`); };\nconst warn = msg => console.warn(`⚠️ ${msg}`);\n\n// ------------- Show UI -------------\n\nfigma.showUI(\n    `<html><body style=\"margin:8px;font:12px ui-monospace,monospace\">\n    <div id=out style=\"white-space:pre;max-width:460px;margin-bottom:6px\"></div>\n    <label for=txt style=\"display:block;margin-bottom:4px;font-weight:600;\">Insert JSON:</label>\n    <textarea id=txt rows=8 placeholder='{\"meta\": {...}, \"variables\": {...}, \"nodes\": [...] }'\n      style=\"width:460px;max-width:460px;font:12px ui-monospace,monospace;white-space:pre\"></textarea><br/>\n    <div style=\"margin-top:6px;display:flex;gap:6px\">\n      <button id=apply>Apply JSON</button>\n      <button id=retie>Re-tie page to variables</button>\n    </div>\n\n    <script>\n      const out = document.getElementById('out');\n      const txt = document.getElementById('txt');\n      const btnApply = document.getElementById('apply');\n      const btnRetie = document.getElementById('retie');\n      const log = (m) => out.textContent += (m + \"\\\\n\");\n      window.onmessage = (e) => { const m = e.data.pluginMessage; if (m && m.type === 'log') log(m.text); };\n\n      btnApply.onclick = () => parent.postMessage({ pluginMessage:{ type:'apply-json', text: txt.value } }, '*');\n      btnRetie.onclick  = () => parent.postMessage({ pluginMessage:{ type:'retie' } }, '*');\n    </script>\n  </body></html>`,\n    { width: 500, height: 360 }\n);\n\n// -------------------- Communications --------------------\nfigma.ui.onmessage = async (msg) => {\n    if (msg?.type === \"retie\") {\n        await retiePageToVariables();\n        return;\n    }\n    if (msg?.type !== \"apply-json\") return;\n\n    try {\n        const raw = msg.text;\n        const parsed = typeof raw === \"string\" ? JSON.parse(raw) : raw;\n        const jsonfile = parseLoadedFile(parsed);\n\n        applyMeta(jsonfile.meta);\n        await applyVariables(jsonfile.variables);\n        await applyNodes(jsonfile.nodes);\n\n        ok(\"Changes applied\");\n    } catch (e) {\n        err(\"apply-json failed: \" + String((e as any)?.message ?? e));\n    }\n};\n\n\n// -------------------- Pipeline --------------------\n\n    async function applyJSONFile(jsonfile: { schema:any; meta:any; variables:any; nodes:any; }) {\n        applyMeta(jsonfile.meta);\n        await applyVariables(jsonfile.variables, jsonfile.meta?.renameCollections); // ← pass map\n        await applyNodes(jsonfile.nodes);\n    }\n\n\n// -------------------- Parsing / Normalization --------------------\n\n    function parseLoadedFile(obj: any) {\n        if (!obj || typeof obj !== \"object\") throw new Error(\"JSON must be an object\");\n        return {\n            schema: obj[\"$schema\"] || null,\n            meta: obj.meta || {},\n            variables: obj.variables || { collectionsCount: 0, collections: [] },\n            nodes: obj.nodes || null\n        };\n    }\n\n        // -------------------- Meta --------------------\n\n        function applyMeta(meta: any = {}) {\n            try {\n                // store what we can at document scope\n                if (meta.fileName) figma.root.setPluginData(\"yy_desiredFileName\", String(meta.fileName)); // cannot actually rename file\n                if (meta.scanId)   figma.root.setPluginData(\"yy_scanId\",       String(meta.scanId));\n                if (meta.pageName) figma.root.setPluginData(\"yy_pageName\",     String(meta.pageName));\n                if (meta.author)   figma.root.setPluginData(\"yy_author\",       String(meta.author));\n                if (meta.version)  figma.root.setPluginData(\"yy_version\",      String(meta.version));\n\n                // optional shared plugin data (namespaced) for team-wide visibility\n                try {\n                    const NS = \"yy\";\n                    Object.entries(meta).forEach(([k,v]) => { if (v != null) figma.root.setSharedPluginData(NS, k, String(v)); });\n                } catch {}\n\n                const desired = figma.root.getPluginData(\"yy_desiredFileName\");\n                if (desired) ok(`Please rename this file to: ${desired} (plugins can’t rename files)`);\n                log(\"Meta saved: \" + JSON.stringify({ fileName: meta.fileName, scanId: meta.scanId, pageName: meta.pageName, author: meta.author, version: meta.version }));\n            } catch (e) { err(\"applyMeta: \" + String(e)); }\n        }\n\n        // -------------------- Variables (collections only, correct API) --------------------\n        // Note: variable APIs differ between plugin runtime versions. We feature-detect and keep things safe.\n\n        async function applyVariables(variables: any = { collections: [] }) {\n            try {\n                if (!figma.variables) { log(\"Variable API unavailable\"); return; }\n                const cols = Array.isArray(variables?.collections) ? variables.collections : [];\n                if (!cols.length) { log(\"No variable collections to apply\"); return; }\n\n                const TYPE: Record<string, VariableResolvedDataType> = {\n                    COLOR: \"COLOR\", FLOAT: \"FLOAT\", STRING: \"STRING\", BOOLEAN: \"BOOLEAN\", NUMBER: \"FLOAT\"\n                };\n\n                const localCollections = await figma.variables.getLocalVariableCollectionsAsync();\n                const collectionByName = new Map(localCollections.map(c => [c.name, c]));\n\n                for (const c of cols) {\n                    const name = String(c?.name || \"\").trim();\n                    if (!name) { log(\"Skip unnamed collection\"); continue; }\n\n                    // 1) ensure collection\n                    let collection = collectionByName.get(name);\n                    // Handle renames first\n                    if (!collection) {\n                        collection = figma.variables.createVariableCollection(name);\n                        collectionByName.set(name, collection);\n                        log(`Created collection: \"${name}\" (${collection.id})`);\n                    } else {\n                        log(`Collection exists: \"${name}\"`);\n                    }\n\n                    // 2) ensure modes (on the collection)\n                    const wantModes = (Array.isArray(c?.modes) ? c.modes : []).map((m:any)=>String(m?.name||\"\").trim()).filter(Boolean);\n                    if (wantModes.length) {\n                        // if collection has a single default mode, rename it to the first desired mode\n                        if (collection.modes.length === 1 && collection.modes[0].name !== wantModes[0]) {\n                            collection.renameMode(collection.modes[0].modeId, wantModes[0]);\n                            log(`  • renamed default mode → ${wantModes[0]}`);\n                        }\n                        // add any missing modes\n                        for (const m of wantModes) {\n                            if (!collection.modes.find(x => x.name === m)) {\n                                collection.addMode(m);\n                                log(`  • added mode: ${m}`);\n                            }\n                        }\n                    } else if (!collection.modes.length) {\n                        collection.addMode(\"Base\");\n                    }\n\n                    // refresh mode map\n                    const modeIdByName = new Map(collection.modes.map(m => [m.name, m.modeId]));\n\n                    // 3) variables\n                    const wantVars = Array.isArray(c?.variables) ? c.variables : [];\n                    if (!wantVars.length) { log(`  (no variables in \"${name}\")`); continue; }\n\n                    const localVars = (await figma.variables.getLocalVariablesAsync())\n                        .filter(v => v.variableCollectionId === collection.id);\n                    const varByName = new Map(localVars.map(v => [v.name, v]));\n\n                    for (const v of wantVars) {\n                        const vName = String(v?.name || \"\").trim(); if (!vName) { log(\"  - skip unnamed variable\"); continue; }\n                        const vType = TYPE[String(v?.type || \"\").toUpperCase()] ?? \"STRING\";\n                        const valuesByMode = (v?.valuesByMode && typeof v.valuesByMode === \"object\") ? v.valuesByMode : {};\n\n                        // create or recreate if type mismatch\n                        let variable = varByName.get(vName);\n                        if (!variable) {\n                            variable = figma.variables.createVariable(vName, collection.id, vType);\n                            varByName.set(vName, variable);\n                            log(`  + var: ${vName} (${vType})`);\n                        } else if (variable.resolvedType !== vType) {\n                            log(`  ! type mismatch for ${vName} (have ${variable.resolvedType}, want ${vType}) — recreating`);\n                            variable.remove();\n                            variable = figma.variables.createVariable(vName, collection.id, vType);\n                            varByName.set(vName, variable);\n                        } else {\n                            log(`  = var: ${vName}`);\n                        }\n\n                        // set values per mode\n                        for (const [modeName, raw] of Object.entries(valuesByMode)) {\n                            const modeId = modeIdByName.get(modeName);\n                            if (!modeId) { log(`    • mode \"${modeName}\" not found in \"${name}\"`); continue; }\n\n                            try {\n                                let val: any = raw;\n                                if (vType === \"COLOR\") {\n                                    const { r, g, b, a } = hexToRgb01(String(raw).trim());\n                                    val = { r, g, b, a }; // RGBA in 0–1 (what Variables expect)\n                                } else if (vType === \"FLOAT\") {\n                                    val = Number(raw);\n                                } else if (vType === \"BOOLEAN\") {\n                                    val = Boolean(raw);\n                                } else {\n                                    val = String(raw);\n                                }\n                                variable.setValueForMode(modeId, val);\n                                log(`    • set ${vName} @ ${modeName}`);\n                            } catch (e) {\n                                err(`    set ${vName} @ ${modeName}: ${String(e)}`);\n                            }\n                        }\n                    }\n                }\n            } catch (e) {\n                err(\"applyVariables: \" + String(e));\n            }\n        }\n\n        // helper\n        function hexToRgb01(hex: string){ const h=hex.replace(\"#\",\"\").trim();\n            let r=0,g=0,b=0,a=1; if(h.length===3){r=parseInt(h[0]+h[0],16);g=parseInt(h[1]+h[1],16);b=parseInt(h[2]+h[2],16);}\n            else if(h.length===6){r=parseInt(h.slice(0,2),16);g=parseInt(h.slice(2,4),16);b=parseInt(h.slice(4,6),16);}\n            else if(h.length===8){r=parseInt(h.slice(0,2),16);g=parseInt(h.slice(2,4),16);b=parseInt(h.slice(4,6),16);a=parseInt(h.slice(6,8),16)/255;}\n            return { r:r/255,g:g/255,b:b/255,a };\n        }\n\n\n\n        // -------------------- Nodes --------------------\n        async function applyNodes(nodes: any) {\n            let updatedCount = 0;\n            if (!nodes) return log(\"No changes found\");\n\n            const arr = Array.isArray(nodes) ? nodes : [nodes];\n            const nodeMap = new Map<string, SceneNode>();\n            const componentMap = new Map<string, ComponentNode>();\n\n            async function createNode(spec: any, parent?: BaseNode & ChildrenMixin): Promise<BaseNode | null> {\n                const t = (spec?.type || spec?.kind || \"\").toUpperCase();\n                // --- SAFETY: never edit component masters directly ---\n                if (spec.id) {\n                    const node = figma.getNodeById(spec.id);\n                    if (node && node.type === \"COMPONENT\" && !node.mainComponent) {\n                        log(`⛔ Skipping component master: ${node.name}`);\n                        return null;\n                    }\n                    }\n\n                let node: SceneNode | null = null;\n\n                try {\n                    switch (t) {\n\n                        // ──────────────────────────── FRAME UPDATE ────────────────────────────\n                        case \"FRAME\":\n                        case \"FRAME-SNAPSHOT\": {\n                            const id = spec?.id;\n                            if (!id) { log(\"frame-snapshot missing id\"); break; }\n\n                            const existing = figma.getNodeById(id);\n                            if (existing.type !== \"FRAME\" && existing.type !== \"INSTANCE\") {\n                                log(`Node ${id} not a FRAME or INSTANCE — skipped`);\n                                break;\n                            }\n\n                            const f = existing as FrameNode;\n                            const p = spec.absPos, s = spec.size;\n\n                            if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) {\n                                f.x = p.x; f.y = p.y;\n                                log(`pos → ${p.x},${p.y}`);\n                            }\n                            if (s && Number.isFinite(s.w) && Number.isFinite(s.h)) {\n                                f.resize(s.w, s.h);\n                                log(`size → ${s.w}×${s.h}`);\n                            }\n                            ok(`Frame updated: ${f.name}`);\n\n                            if (Array.isArray(spec.children)) {\n                                for (const child of spec.children) {\n                                    await createNode(child, f);\n                                }\n                            }\n                            break;\n                        }\n\n                        // ──────────────────────────── INSTANCE UPDATE ────────────────────────────\n                        // -------------------- Instance Update (for swatch palettes) --------------------\n                        case \"INSTANCE-UPDATE\": {\n                            const name = String(spec?.name || \"\").trim();\n                            if (!name) { log(\"Instance-update missing name\"); break; }\n\n                            // Find the instance node by name\n                            const inst = figma.currentPage.findOne(\n                                n => n.name === name && (n.type === \"INSTANCE\" || n.type === \"FRAME\")\n                            ) as InstanceNode | FrameNode | null;\n\n                            if (!inst) { warn(`Instance \"${name}\" not found`); break; }\n\n                            // --- Skip master components to avoid overwriting them ---\n                            if (inst.type === \"COMPONENT\") {\n                                log(`⏭️ Skipping master component: ${name}`);\n                                break;\n                            }\n\n                            // --- Update the color rectangle fill ---\n                            let colorRect: RectangleNode | null = null;\n                            try {\n                                colorRect = inst.findOne(n => n.name === \"ColorBox\") as RectangleNode | null;\n                                if (colorRect) {\n                                    // Apply solid color if Hex provided\n                                    if (spec.Hex) {\n                                        const { r, g, b, a } = hexToRgb01(spec.Hex);\n                                        colorRect.fills = [{ type: \"SOLID\", color: { r, g, b }, opacity: a }];\n                                        log(`🎨 Updated fill color for ${name}`);\n                                    }\n\n                                    // --- Bind Variable if specified ---\n                                    if (spec.variableAlias && colorRect) {\n                                        try {\n                                            const variable = figma.variables.getVariableById(spec.variableAlias);\n                                            if (variable) {\n                                                // Ensure there’s at least one fill to attach to\n                                                if (!colorRect.fills || colorRect.fills.length === 0) {\n                                                    colorRect.fills = [{type: \"SOLID\", color: {r: 1, g: 1, b: 1}}];\n                                                }\n\n                                                colorRect.boundVariables = {\n                                                    fills: {id: variable.id, type: \"VARIABLE_ALIAS\"}\n                                                };\n\n                                                log(`✅ Bound ${name} to variable: ${variable.name}`);\n                                            } else {\n                                                warn(`⚠️ Variable not found: ${spec.variableAlias}`);\n                                            }\n                                        } catch (e) {\n                                            err(`Failed to bind variable for ${name}: ${String(e)}`);\n                                        }\n                                    }\n\n                                    // --- Update text layers (Label + Hex) ---\n                            try {\n                                const label = inst.findOne(n => n.name === \"Label\") as TextNode | null;\n                                if (label && spec.Label) {\n                                    await figma.loadFontAsync(label.fontName as FontName);\n                                    label.characters = spec.Label;\n                                }\n\n                                const hexText = inst.findOne(n => n.name === \"Hex\") as TextNode | null;\n                                if (hexText && spec.Hex) {\n                                    await figma.loadFontAsync(hexText.fontName as FontName);\n                                    hexText.characters = spec.Hex;\n                                }\n\n                                log(`📝 Updated text for ${name}`);\n                            } catch (e) {\n                                warn(`⚠️ Text update failed in ${name}: ${String(e)}`);\n                            }\n\n                            updatedCount++;\n                            break;\n                        }\n\n\n                        // ──────────────────────────── INSTANCE CREATION ────────────────────────────\n                        case \"INSTANCE\": {\n                            try {\n                                const componentId = String(spec?.componentId || \"\").trim();\n                                if (!componentId) { log(\"Instance missing componentId\"); break; }\n\n                                // Find the component in the document\n                                const comp = figma.getNodeById(componentId) as ComponentNode | null;\n                                if (!comp) { log(`Component not found for id: ${componentId}`); break; }\n\n                                // Create the instance\n                                const inst = comp.createInstance();\n                                if (spec.name) inst.name = spec.name;\n\n                                // Optional positioning\n                                if (spec.absPos) { inst.x = spec.absPos.x || 0; inst.y = spec.absPos.y || 0; }\n                                if (spec.size) inst.resize(spec.size.w || inst.width, spec.size.h || inst.height);\n\n                                // Optional auto layout configuration\n                                if (spec.autoLayout) {\n                                    const f = inst as FrameNode;\n                                    f.layoutMode = spec.autoLayout.direction === \"VERTICAL\" ? \"VERTICAL\" : \"HORIZONTAL\";\n                                    f.itemSpacing = spec.autoLayout.spacing ?? 8;\n                                    f.paddingLeft = f.paddingRight = f.paddingTop = f.paddingBottom = spec.autoLayout.padding ?? 0;\n                                }\n\n                                // Attach to current page\n                                figma.currentPage.appendChild(inst);\n\n                                ok(`Created instance: ${inst.name}`);\n                            } catch (e) {\n                                err(`createInstance: ${String(e)}`);\n                            }\n                            break;\n                        }\n\n                        // ──────────────────────────── UNKNOWN / UNSUPPORTED ────────────────────────────\n                        default:\n                            err(`Unknown node type: ${t} — skipped (no fallback creation)`);\n                            break;\n                    }\n\n                    // shared property updates (for newly created or updated nodes)\n                    if (node && spec.name) node.name = spec.name;\n                    if (node && spec.size) node.resize(spec.size.w || node.width, spec.size.h || node.height);\n                    if (node && spec.absPos) { node.x = spec.absPos.x || 0; node.y = spec.absPos.y || 0; }\n\n                    // auto layout\n                    if (node && spec.autoLayout) {\n                        const f = node as FrameNode | ComponentNode;\n                        f.layoutMode = spec.autoLayout.direction === \"VERTICAL\" ? \"VERTICAL\" : \"HORIZONTAL\";\n                        f.itemSpacing = spec.autoLayout.spacing ?? 8;\n                        f.paddingLeft = f.paddingRight = f.paddingTop = f.paddingBottom = spec.autoLayout.padding ?? 0;\n                    }\n\n                    // solid fill (if explicitly given)\n                    if (node && spec.fill) {\n                        const { r, g, b, a } = hexToRgb01(spec.fill);\n                        (node as GeometryMixin).fills = [{ type: \"SOLID\", color: { r, g, b }, opacity: a }];\n                    }\n\n                    // recurse into children\n                    if (node && Array.isArray(spec.children)) {\n                        for (const child of spec.children) await createNode(child, node as BaseNode & ChildrenMixin);\n                    }\n\n                    // store references\n                    if (node && spec.id) nodeMap.set(spec.id, node);\n                    if (node && t === \"COMPONENT\" && spec.id) componentMap.set(spec.id, node as ComponentNode);\n\n                    if (node) ok(`Created or updated ${t}: ${spec.name || \"(unnamed)\"}`);\n                    return node;\n\n                } catch (e) {\n                    err(`createNode(${spec?.name || t}): ${String(e)}`);\n                    return null;\n                }\n            }\n\n            // ──────────────────────────── Main Loop ────────────────────────────\n            for (const spec of arr) {\n                // 🔒 Skip master components even if the JSON includes their ID\n                if (spec.id) {\n                    const nodeById = figma.getNodeById(spec.id);\n                    if (nodeById && nodeById.type === \"COMPONENT\" && !nodeById.mainComponent) {\n                        log(`⛔ Skipping main component for id ${spec.id}`);\n                        continue;\n                    }\n\n                    // ✅ Safe path for instances or frames\n                    if (nodeById && (nodeById.type === \"INSTANCE\" || nodeById.type === \"FRAME\")) {\n                        log(`Updating existing instance/frame by ID: ${nodeById.name}`);\n                        if (Array.isArray(spec.children)) {\n                            for (const c of spec.children) await createNode(c, nodeById);\n                        }\n                        continue;\n                    }\n                }\n\n                // Fallback by name if ID not found\n                const target = figma.currentPage.findOne(\n                    n => n.name === spec.name && (n.type === \"INSTANCE\" || n.type === \"FRAME\")\n                );\n                if (target) {\n                    log(`Updating existing node by name: ${target.name}`);\n                    if (Array.isArray(spec.children)) {\n                        for (const c of spec.children) await createNode(c, target);\n                    }\n                    continue;\n                }\n\n                await createNode(spec, figma.currentPage);\n            }\n\n\n            ok(`Created or updated ${nodeMap.size} nodes total`);\n        }\n\n\n\n// -------------------------------- Re-tie page to Variables --------------------------------\nasync function retiePageToVariables() {\n    if (!figma.variables) { log(\"Variables API unavailable\"); return; }\n\n    // --- setup ---\n    // 1) collections (local only)\n    const collections = await figma.variables.getLocalVariableCollectionsAsync();\n\n    // 2) variables: try local first, then per-collection fallback\n    let vars: Variable[] = await figma.variables.getLocalVariablesAsync();  // single declaration\n    if (!Array.isArray(vars)) vars = [];\n    if (vars.length === 0) {\n        // fallback: gather variables from each local collection\n        for (const c of collections) {\n            try {\n                const got = await figma.variables.getVariablesInCollectionAsync(c.id);\n                if (Array.isArray(got) && got.length) vars.push(...got);\n            } catch (e) {\n                log(`retie: getVariablesInCollectionAsync failed for \"${c.name}\": ${String(e)}`);\n            }\n        }\n    }\n\n    log(`retie: found ${collections.length} collections, ${vars.length} variables`);\n\n    // quick exits to avoid doing work if truly empty\n    if (!collections.length || !vars.length) {\n        ok(\"Re-tied 0 properties on this page\");\n        return;\n    }\n\n    // lookups (for binding)\n    const varById     = new Map(vars.map(v => [v.id, v]));\n\n    // indexes must exist here so both indexer + binder can see them\n    const colorIdx = new Map<string, { id:string; name:string }>();\n    const numIdx   = new Map<number, { id:string; name:string }>();\n    const strIdx   = new Map<string, { id:string; name:string }>();\n\n    // tolerant color key\n    const round255 = (x: number) => Math.round((x ?? 1) * 255);\n    const keyRGBA  = (r:number,g:number,b:number,a:number) =>\n        `${round255(r)},${round255(g)},${round255(b)},${round255(a ?? 1)}`;\n\n    // API compatibility: old vs new\n    const getVal = (v: any, modeId: string) => {\n        try {\n            if (typeof v.getValueForMode === \"function\") return v.getValueForMode(modeId);\n            if (typeof v.getValueForModeId === \"function\") return v.getValueForModeId(modeId);\n        } catch (_) { /* ignore */ }\n\n        // 🔧 fallback: read from valuesByMode object (some builds require this)\n        if (v.valuesByMode && typeof v.valuesByMode === \"object\") {\n            const val = v.valuesByMode[modeId];\n            if (val !== undefined) return val;\n        }\n\n        return undefined;\n    };\n\n    // Index every variable for all modes in its collection\n    for (const v of vars) {\n        const col = collections.find(c => c.id === v.variableCollectionId);\n        if (!col) continue;\n        for (const m of col.modes) {\n            const val = getVal(v, m.modeId);\n            if (val == null) continue;\n            if (v.resolvedType === \"COLOR\" && typeof val === \"object\" && \"r\" in val) {\n                const {r,g,b,a} = val as {r:number;g:number;b:number;a:number};\n                colorIdx.set(keyRGBA(r,g,b,a), {id:v.id, name:v.name});\n            } else if (v.resolvedType === \"FLOAT\") {\n                const n = Number(val);\n                if (Number.isFinite(n)) numIdx.set(n, {id:v.id, name:v.name});\n            } else if (v.resolvedType === \"STRING\") {\n                strIdx.set(String(val), {id:v.id, name:v.name});\n            }\n        }\n    }\n\n    log(`indexed ${colorIdx.size} colors, ${numIdx.size} numbers, ${strIdx.size} strings`);\n\n    // --- walk nodes + bind ---\n    const solidRGBA = (p: SolidPaint) => {\n        const a = typeof p.opacity === \"number\" ? p.opacity : 1;\n        return {r:p.color.r, g:p.color.g, b:p.color.b, a};\n    };\n    const nodes = figma.currentPage.findAll();\n    let bound = 0;\n\n    function bindPaintColor(node: any, prop: \"fills\" | \"strokes\", varId: string) {\n        const variable = varById.get(varId);\n        if (!variable) { log(`WARN paint: missing var ${varId}`); return false; }\n\n        const paints = node[prop] as ReadonlyArray<Paint>;\n        if (!Array.isArray(paints) || paints.length === 0) return false;\n\n        const p0 = paints[0];\n        if (p0.type !== \"SOLID\") return false;\n\n        // clone paint without spread\n        const newPaint: SolidPaint = Object.assign({}, p0) as SolidPaint;\n\n        // keep existing boundVariables (if any) without spread\n        const existingBV: any = (p0 as any).boundVariables || {};\n        const nextBV: any = Object.assign({}, existingBV, {\n            // ✅ REQUIRED SHAPE\n            color: { type: \"VARIABLE_ALIAS\", id: variable.id }\n        });\n\n        (newPaint as any).boundVariables = nextBV;\n\n        // write back paints (replace index 0) without spread\n        const next = paints.slice();\n        next[0] = newPaint;\n\n        try {\n            (node as any)[prop] = next;\n            return true;\n        } catch (e) {\n            log(`bind ${prop} color failed: ${String(e)}`);\n            return false;\n        }\n    }\n\n    const bind = (node:any, prop:string, varId:string) => {\n        const variable = varById.get(varId);\n        if (!variable) return;\n        try { node.setBoundVariable(prop, variable); bound++; }\n        catch(e){ log(`bind ${prop} failed: ${String(e)}`); }\n    };\n\n    for (const node of nodes) {\n        // fills\n        if (\"fills\" in node) {\n            const fs = (node as GeometryMixin).fills;\n            if (Array.isArray(fs) && fs.length && fs[0].type === \"SOLID\") {   // ← changed\n                const { r,g,b,a } = solidRGBA(fs[0] as SolidPaint);\n                const m = colorIdx.get(keyRGBA(r,g,b,a));\n                if (m && bindPaintColor(node, \"fills\", m.id)) { bound++; log(`bind fills → ${m.name}`); }\n            }\n        }\n\n        // strokes\n        if (\"strokes\" in node) {\n            const st = (node as GeometryMixin).strokes;\n            if (Array.isArray(st) && st.length && st[0].type === \"SOLID\") {   // ← changed\n                const { r,g,b,a } = solidRGBA(st[0] as SolidPaint);\n                const m = colorIdx.get(keyRGBA(r,g,b,a));\n                if (m && bindPaintColor(node, \"strokes\", m.id)) { bound++; log(`bind strokes → ${m.name}`); }\n            }\n        }\n\n        // text\n        if (node.type === \"TEXT\") {\n            const t = node as TextNode;\n            if (typeof t.fontSize === \"number\") {\n                const m = numIdx.get(t.fontSize); if (m) { bind(t, \"fontSize\", m.id); log(`bind fontSize → ${m.name}`); }\n            }\n            const lh: any = t.lineHeight;\n            if (lh && typeof lh === \"object\" && lh.unit === \"PIXELS\" && typeof lh.value === \"number\") {\n                const m = numIdx.get(lh.value); if (m) { bind(t, \"lineHeight\", m.id); log(`bind lineHeight → ${m.name}`); }\n            }\n            const tf = t.fills as ReadonlyArray<Paint>;\n            if (Array.isArray(t.fills) && t.fills.length && t.fills[0].type === \"SOLID\") {\n                const { r,g,b,a } = solidRGBA(t.fills[0] as SolidPaint);\n                const m = colorIdx.get(keyRGBA(r,g,b,a));\n                if (m && bindPaintColor(t, \"fills\", m.id)) { bound++; log(`bind text fill → ${m.name}`); }\n            }\n        }\n        // layout numerics\n        const n:any = node;\n        const numericProps = [\"itemSpacing\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"paddingBottom\",\"cornerRadius\",\"strokeWeight\"];\n        for (const prop of numericProps) {\n            if (typeof n[prop] === \"number\") {\n                const m = numIdx.get(n[prop]); if (m) { bind(node, prop, m.id); log(`bind ${prop} → ${m.name}`); }\n            }\n        }\n    }\n\n    ok(`Re-tied ${bound} properties on this page`);\n}\n\n\n\n\n\n// ready\n\nlog(\"YY Make Changes ready\");\nfigma.notify(\"YY Make Changes plugin ready\");\n"
    },
    {
      "name": "manifest.json",
      "type": "file",
      "content": "{\n  \"name\": \"YY Figma Assistant — Implement\",\n  \"id\": \"yyfa-implement\",\n  \"api\": \"1.0.0\",\n  \"editorType\": [\"figma\"],\n  \"main\": \"main-implement.js\",\n  \"enableProposedApi\": true\n}\n"
    },
    {
      "name": "package.json",
      "type": "file",
      "content": "{\n  \"scripts\": {\n    \"b\": \"esbuild main-implement.ts --outfile=main-implement.js --format=iife --platform=browser --target=es2018\"\n  }\n}"
    },
    {
      "name": "repo-full.json",
      "type": "file",
      "content": "{\n  \"name\": \"Figma-Plugin-YY-Assistant\",\n  \"type\": \"folder\",\n  \"children\": [\n    {\n      \"name\": \".DS_Store\",\n      \"type\": \"file\",\n      \"content\": null\n    },\n    {\n      \"name\": \".gitignore\",\n      \"type\": \"file\",\n      \"content\": null\n    },\n    {\n      \"name\": \"main-implement.js\",\n      \"type\": \"file\",\n      \"content\": \"(() => {\\n  const uiLog = (text) => {\\n    try {\\n      figma.ui.postMessage({ type: \\\"log\\\", text });\\n    } catch (_) {\\n    }\\n  };\\n  const log = (...a) => {\\n    console.log(\\\"[YY-MakeChanges]\\\", ...a);\\n    uiLog(a.map(String).join(\\\" \\\"));\\n  };\\n  const ok = (m) => {\\n    figma.notify(`\\\\u2705 ${m}`);\\n    uiLog(`\\\\u2705 ${m}`);\\n  };\\n  const err = (m) => {\\n    figma.notify(`\\\\u26A0\\\\uFE0F ${m}`);\\n    uiLog(`\\\\u26A0\\\\uFE0F ${m}`);\\n  };\\n  const warn = (msg) => console.warn(`\\\\u26A0\\\\uFE0F ${msg}`);\\n  figma.showUI(\\n    `<html><body style=\\\"margin:8px;font:12px ui-monospace,monospace\\\">\\n    <div id=out style=\\\"white-space:pre;max-width:460px;margin-bottom:6px\\\"></div>\\n    <label for=txt style=\\\"display:block;margin-bottom:4px;font-weight:600;\\\">Insert JSON:</label>\\n    <textarea id=txt rows=8 placeholder='{\\\"meta\\\": {...}, \\\"variables\\\": {...}, \\\"nodes\\\": [...] }'\\n      style=\\\"width:460px;max-width:460px;font:12px ui-monospace,monospace;white-space:pre\\\"></textarea><br/>\\n    <div style=\\\"margin-top:6px;display:flex;gap:6px\\\">\\n      <button id=apply>Apply JSON</button>\\n      <button id=retie>Re-tie page to variables</button>\\n    </div>\\n\\n    <script>\\n      const out = document.getElementById('out');\\n      const txt = document.getElementById('txt');\\n      const btnApply = document.getElementById('apply');\\n      const btnRetie = document.getElementById('retie');\\n      const log = (m) => out.textContent += (m + \\\"\\\\\\\\n\\\");\\n      window.onmessage = (e) => { const m = e.data.pluginMessage; if (m && m.type === 'log') log(m.text); };\\n\\n      btnApply.onclick = () => parent.postMessage({ pluginMessage:{ type:'apply-json', text: txt.value } }, '*');\\n      btnRetie.onclick  = () => parent.postMessage({ pluginMessage:{ type:'retie' } }, '*');\\n    <\\\\/script>\\n  </body></html>`,\\n    { width: 500, height: 360 }\\n  );\\n  figma.ui.onmessage = async (msg) => {\\n    var _a;\\n    if ((msg == null ? void 0 : msg.type) === \\\"retie\\\") {\\n      await retiePageToVariables();\\n      return;\\n    }\\n    if ((msg == null ? void 0 : msg.type) !== \\\"apply-json\\\") return;\\n    try {\\n      const raw = msg.text;\\n      const parsed = typeof raw === \\\"string\\\" ? JSON.parse(raw) : raw;\\n      const jsonfile = parseLoadedFile(parsed);\\n      applyMeta(jsonfile.meta);\\n      await applyVariables(jsonfile.variables);\\n      await applyNodes(jsonfile.nodes);\\n      ok(\\\"Changes applied\\\");\\n    } catch (e) {\\n      err(\\\"apply-json failed: \\\" + String((_a = e == null ? void 0 : e.message) != null ? _a : e));\\n    }\\n  };\\n  function parseLoadedFile(obj) {\\n    if (!obj || typeof obj !== \\\"object\\\") throw new Error(\\\"JSON must be an object\\\");\\n    return {\\n      schema: obj[\\\"$schema\\\"] || null,\\n      meta: obj.meta || {},\\n      variables: obj.variables || { collectionsCount: 0, collections: [] },\\n      nodes: obj.nodes || null\\n    };\\n  }\\n  function applyMeta(meta = {}) {\\n    try {\\n      if (meta.fileName) figma.root.setPluginData(\\\"yy_desiredFileName\\\", String(meta.fileName));\\n      if (meta.scanId) figma.root.setPluginData(\\\"yy_scanId\\\", String(meta.scanId));\\n      if (meta.pageName) figma.root.setPluginData(\\\"yy_pageName\\\", String(meta.pageName));\\n      if (meta.author) figma.root.setPluginData(\\\"yy_author\\\", String(meta.author));\\n      if (meta.version) figma.root.setPluginData(\\\"yy_version\\\", String(meta.version));\\n      try {\\n        const NS = \\\"yy\\\";\\n        Object.entries(meta).forEach(([k, v]) => {\\n          if (v != null) figma.root.setSharedPluginData(NS, k, String(v));\\n        });\\n      } catch (e) {\\n      }\\n      const desired = figma.root.getPluginData(\\\"yy_desiredFileName\\\");\\n      if (desired) ok(`Please rename this file to: ${desired} (plugins can\\\\u2019t rename files)`);\\n      log(\\\"Meta saved: \\\" + JSON.stringify({ fileName: meta.fileName, scanId: meta.scanId, pageName: meta.pageName, author: meta.author, version: meta.version }));\\n    } catch (e) {\\n      err(\\\"applyMeta: \\\" + String(e));\\n    }\\n  }\\n  async function applyVariables(variables = { collections: [] }) {\\n    var _a;\\n    try {\\n      if (!figma.variables) {\\n        log(\\\"Variable API unavailable\\\");\\n        return;\\n      }\\n      const cols = Array.isArray(variables == null ? void 0 : variables.collections) ? variables.collections : [];\\n      if (!cols.length) {\\n        log(\\\"No variable collections to apply\\\");\\n        return;\\n      }\\n      const TYPE = {\\n        COLOR: \\\"COLOR\\\",\\n        FLOAT: \\\"FLOAT\\\",\\n        STRING: \\\"STRING\\\",\\n        BOOLEAN: \\\"BOOLEAN\\\",\\n        NUMBER: \\\"FLOAT\\\"\\n      };\\n      const localCollections = await figma.variables.getLocalVariableCollectionsAsync();\\n      const collectionByName = new Map(localCollections.map((c) => [c.name, c]));\\n      for (const c of cols) {\\n        const name = String((c == null ? void 0 : c.name) || \\\"\\\").trim();\\n        if (!name) {\\n          log(\\\"Skip unnamed collection\\\");\\n          continue;\\n        }\\n        let collection = collectionByName.get(name);\\n        if (!collection) {\\n          collection = figma.variables.createVariableCollection(name);\\n          collectionByName.set(name, collection);\\n          log(`Created collection: \\\"${name}\\\" (${collection.id})`);\\n        } else {\\n          log(`Collection exists: \\\"${name}\\\"`);\\n        }\\n        const wantModes = (Array.isArray(c == null ? void 0 : c.modes) ? c.modes : []).map((m) => String((m == null ? void 0 : m.name) || \\\"\\\").trim()).filter(Boolean);\\n        if (wantModes.length) {\\n          if (collection.modes.length === 1 && collection.modes[0].name !== wantModes[0]) {\\n            collection.renameMode(collection.modes[0].modeId, wantModes[0]);\\n            log(`  \\\\u2022 renamed default mode \\\\u2192 ${wantModes[0]}`);\\n          }\\n          for (const m of wantModes) {\\n            if (!collection.modes.find((x) => x.name === m)) {\\n              collection.addMode(m);\\n              log(`  \\\\u2022 added mode: ${m}`);\\n            }\\n          }\\n        } else if (!collection.modes.length) {\\n          collection.addMode(\\\"Base\\\");\\n        }\\n        const modeIdByName = new Map(collection.modes.map((m) => [m.name, m.modeId]));\\n        const wantVars = Array.isArray(c == null ? void 0 : c.variables) ? c.variables : [];\\n        if (!wantVars.length) {\\n          log(`  (no variables in \\\"${name}\\\")`);\\n          continue;\\n        }\\n        const localVars = (await figma.variables.getLocalVariablesAsync()).filter((v) => v.variableCollectionId === collection.id);\\n        const varByName = new Map(localVars.map((v) => [v.name, v]));\\n        for (const v of wantVars) {\\n          const vName = String((v == null ? void 0 : v.name) || \\\"\\\").trim();\\n          if (!vName) {\\n            log(\\\"  - skip unnamed variable\\\");\\n            continue;\\n          }\\n          const vType = (_a = TYPE[String((v == null ? void 0 : v.type) || \\\"\\\").toUpperCase()]) != null ? _a : \\\"STRING\\\";\\n          const valuesByMode = (v == null ? void 0 : v.valuesByMode) && typeof v.valuesByMode === \\\"object\\\" ? v.valuesByMode : {};\\n          let variable = varByName.get(vName);\\n          if (!variable) {\\n            variable = figma.variables.createVariable(vName, collection.id, vType);\\n            varByName.set(vName, variable);\\n            log(`  + var: ${vName} (${vType})`);\\n          } else if (variable.resolvedType !== vType) {\\n            log(`  ! type mismatch for ${vName} (have ${variable.resolvedType}, want ${vType}) \\\\u2014 recreating`);\\n            variable.remove();\\n            variable = figma.variables.createVariable(vName, collection.id, vType);\\n            varByName.set(vName, variable);\\n          } else {\\n            log(`  = var: ${vName}`);\\n          }\\n          for (const [modeName, raw] of Object.entries(valuesByMode)) {\\n            const modeId = modeIdByName.get(modeName);\\n            if (!modeId) {\\n              log(`    \\\\u2022 mode \\\"${modeName}\\\" not found in \\\"${name}\\\"`);\\n              continue;\\n            }\\n            try {\\n              let val = raw;\\n              if (vType === \\\"COLOR\\\") {\\n                const { r, g, b, a } = hexToRgb01(String(raw).trim());\\n                val = { r, g, b, a };\\n              } else if (vType === \\\"FLOAT\\\") {\\n                val = Number(raw);\\n              } else if (vType === \\\"BOOLEAN\\\") {\\n                val = Boolean(raw);\\n              } else {\\n                val = String(raw);\\n              }\\n              variable.setValueForMode(modeId, val);\\n              log(`    \\\\u2022 set ${vName} @ ${modeName}`);\\n            } catch (e) {\\n              err(`    set ${vName} @ ${modeName}: ${String(e)}`);\\n            }\\n          }\\n        }\\n      }\\n    } catch (e) {\\n      err(\\\"applyVariables: \\\" + String(e));\\n    }\\n  }\\n  function hexToRgb01(hex) {\\n    const h = hex.replace(\\\"#\\\", \\\"\\\").trim();\\n    let r = 0, g = 0, b = 0, a = 1;\\n    if (h.length === 3) {\\n      r = parseInt(h[0] + h[0], 16);\\n      g = parseInt(h[1] + h[1], 16);\\n      b = parseInt(h[2] + h[2], 16);\\n    } else if (h.length === 6) {\\n      r = parseInt(h.slice(0, 2), 16);\\n      g = parseInt(h.slice(2, 4), 16);\\n      b = parseInt(h.slice(4, 6), 16);\\n    } else if (h.length === 8) {\\n      r = parseInt(h.slice(0, 2), 16);\\n      g = parseInt(h.slice(2, 4), 16);\\n      b = parseInt(h.slice(4, 6), 16);\\n      a = parseInt(h.slice(6, 8), 16) / 255;\\n    }\\n    return { r: r / 255, g: g / 255, b: b / 255, a };\\n  }\\n  async function applyNodes(nodes) {\\n    if (!nodes) return log(\\\"No changes found\\\");\\n    const arr = Array.isArray(nodes) ? nodes : [nodes];\\n    const nodeMap = /* @__PURE__ */ new Map();\\n    const componentMap = /* @__PURE__ */ new Map();\\n    async function createNode(spec, parent) {\\n      var _a, _b, _c, _d;\\n      const t = ((spec == null ? void 0 : spec.type) || (spec == null ? void 0 : spec.kind) || \\\"\\\").toUpperCase();\\n      if (spec.id) {\\n        const node2 = figma.getNodeById(spec.id);\\n        if (node2 && node2.type === \\\"COMPONENT\\\" && !node2.mainComponent) {\\n          log(`\\\\u26D4 Skipping component master: ${node2.name}`);\\n          return null;\\n        }\\n      }\\n      let node = null;\\n      try {\\n        switch (t) {\\n          // ──────────────────────────── FRAME UPDATE ────────────────────────────\\n          case \\\"FRAME\\\":\\n          case \\\"FRAME-SNAPSHOT\\\": {\\n            const id = spec == null ? void 0 : spec.id;\\n            if (!id) {\\n              log(\\\"frame-snapshot missing id\\\");\\n              break;\\n            }\\n            const existing = figma.getNodeById(id);\\n            if (existing.type !== \\\"FRAME\\\" && existing.type !== \\\"INSTANCE\\\") {\\n              log(`Node ${id} not a FRAME or INSTANCE \\\\u2014 skipped`);\\n              break;\\n            }\\n            const f = existing;\\n            const p = spec.absPos, s = spec.size;\\n            if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) {\\n              f.x = p.x;\\n              f.y = p.y;\\n              log(`pos \\\\u2192 ${p.x},${p.y}`);\\n            }\\n            if (s && Number.isFinite(s.w) && Number.isFinite(s.h)) {\\n              f.resize(s.w, s.h);\\n              log(`size \\\\u2192 ${s.w}\\\\xD7${s.h}`);\\n            }\\n            ok(`Frame updated: ${f.name}`);\\n            if (Array.isArray(spec.children)) {\\n              for (const child of spec.children) {\\n                await createNode(child, f);\\n              }\\n            }\\n            break;\\n          }\\n          // ──────────────────────────── INSTANCE UPDATE ────────────────────────────\\n          // -------------------- Instance Update (for swatch palettes) --------------------\\n          case \\\"INSTANCE-UPDATE\\\": {\\n            const name = String((spec == null ? void 0 : spec.name) || \\\"\\\").trim();\\n            if (!name) {\\n              log(\\\"Instance-update missing name\\\");\\n              break;\\n            }\\n            const inst = figma.currentPage.findOne(\\n              (n) => n.name === name && (n.type === \\\"INSTANCE\\\" || n.type === \\\"FRAME\\\")\\n            );\\n            if (!inst) {\\n              warn(`Instance \\\"${name}\\\" not found`);\\n              break;\\n            }\\n            if (inst.type === \\\"COMPONENT\\\") {\\n              log(`\\\\u23ED\\\\uFE0F Skipping master component: ${name}`);\\n              break;\\n            }\\n            let colorRect = null;\\n            try {\\n              colorRect = inst.findOne((n) => n.name === \\\"ColorBox\\\");\\n              if (colorRect) {\\n                if (spec.Hex) {\\n                  const { r, g, b, a } = hexToRgb01(spec.Hex);\\n                  colorRect.fills = [{ type: \\\"SOLID\\\", color: { r, g, b }, opacity: a }];\\n                  log(`\\\\u{1F3A8} Updated fill color for ${name}`);\\n                }\\n                if (spec.variableAlias) {\\n                  try {\\n                    const variable = figma.variables.getVariableById(spec.variableAlias);\\n                    if (variable) {\\n                      colorRect.boundVariables = {\\n                        fills: { type: \\\"VARIABLE_ALIAS\\\", id: variable.id }\\n                      };\\n                      log(`\\\\u2705 Bound ${name} fill to variable: ${variable.name}`);\\n                    } else {\\n                      warn(`\\\\u26A0\\\\uFE0F Variable not found: ${spec.variableAlias}`);\\n                    }\\n                  } catch (e) {\\n                    warn(`\\\\u26A0\\\\uFE0F Failed to bind variable for ${name}: ${String(e)}`);\\n                  }\\n                }\\n              } else {\\n                warn(`No \\\"ColorBox\\\" found inside ${name}`);\\n              }\\n            } catch (e) {\\n              err(`Failed to recolor ${name}: ${String(e)}`);\\n            }\\n            try {\\n              const label = inst.findOne((n) => n.name === \\\"Label\\\");\\n              if (label && spec.Label) {\\n                await figma.loadFontAsync(label.fontName);\\n                label.characters = spec.Label;\\n              }\\n              const hexText = inst.findOne((n) => n.name === \\\"Hex\\\");\\n              if (hexText && spec.Hex) {\\n                await figma.loadFontAsync(hexText.fontName);\\n                hexText.characters = spec.Hex;\\n              }\\n              log(`\\\\u{1F4DD} Updated text for ${name}`);\\n            } catch (e) {\\n              warn(`\\\\u26A0\\\\uFE0F Text update failed in ${name}: ${String(e)}`);\\n            }\\n            updatedCount++;\\n            break;\\n          }\\n          // ──────────────────────────── INSTANCE CREATION ────────────────────────────\\n          case \\\"INSTANCE\\\": {\\n            try {\\n              const componentId = String((spec == null ? void 0 : spec.componentId) || \\\"\\\").trim();\\n              if (!componentId) {\\n                log(\\\"Instance missing componentId\\\");\\n                break;\\n              }\\n              const comp = figma.getNodeById(componentId);\\n              if (!comp) {\\n                log(`Component not found for id: ${componentId}`);\\n                break;\\n              }\\n              const inst = comp.createInstance();\\n              if (spec.name) inst.name = spec.name;\\n              if (spec.absPos) {\\n                inst.x = spec.absPos.x || 0;\\n                inst.y = spec.absPos.y || 0;\\n              }\\n              if (spec.size) inst.resize(spec.size.w || inst.width, spec.size.h || inst.height);\\n              if (spec.autoLayout) {\\n                const f = inst;\\n                f.layoutMode = spec.autoLayout.direction === \\\"VERTICAL\\\" ? \\\"VERTICAL\\\" : \\\"HORIZONTAL\\\";\\n                f.itemSpacing = (_a = spec.autoLayout.spacing) != null ? _a : 8;\\n                f.paddingLeft = f.paddingRight = f.paddingTop = f.paddingBottom = (_b = spec.autoLayout.padding) != null ? _b : 0;\\n              }\\n              figma.currentPage.appendChild(inst);\\n              ok(`Created instance: ${inst.name}`);\\n            } catch (e) {\\n              err(`createInstance: ${String(e)}`);\\n            }\\n            break;\\n          }\\n          // ──────────────────────────── UNKNOWN / UNSUPPORTED ────────────────────────────\\n          default:\\n            err(`Unknown node type: ${t} \\\\u2014 skipped (no fallback creation)`);\\n            break;\\n        }\\n        if (node && spec.name) node.name = spec.name;\\n        if (node && spec.size) node.resize(spec.size.w || node.width, spec.size.h || node.height);\\n        if (node && spec.absPos) {\\n          node.x = spec.absPos.x || 0;\\n          node.y = spec.absPos.y || 0;\\n        }\\n        if (node && spec.autoLayout) {\\n          const f = node;\\n          f.layoutMode = spec.autoLayout.direction === \\\"VERTICAL\\\" ? \\\"VERTICAL\\\" : \\\"HORIZONTAL\\\";\\n          f.itemSpacing = (_c = spec.autoLayout.spacing) != null ? _c : 8;\\n          f.paddingLeft = f.paddingRight = f.paddingTop = f.paddingBottom = (_d = spec.autoLayout.padding) != null ? _d : 0;\\n        }\\n        if (node && spec.fill) {\\n          const { r, g, b, a } = hexToRgb01(spec.fill);\\n          node.fills = [{ type: \\\"SOLID\\\", color: { r, g, b }, opacity: a }];\\n        }\\n        if (node && Array.isArray(spec.children)) {\\n          for (const child of spec.children) await createNode(child, node);\\n        }\\n        if (node && spec.id) nodeMap.set(spec.id, node);\\n        if (node && t === \\\"COMPONENT\\\" && spec.id) componentMap.set(spec.id, node);\\n        if (node) ok(`Created or updated ${t}: ${spec.name || \\\"(unnamed)\\\"}`);\\n        return node;\\n      } catch (e) {\\n        err(`createNode(${(spec == null ? void 0 : spec.name) || t}): ${String(e)}`);\\n        return null;\\n      }\\n    }\\n    for (const spec of arr) {\\n      if (spec.id) {\\n        const nodeById = figma.getNodeById(spec.id);\\n        if (nodeById && nodeById.type === \\\"COMPONENT\\\" && !nodeById.mainComponent) {\\n          log(`\\\\u26D4 Skipping main component for id ${spec.id}`);\\n          continue;\\n        }\\n        if (nodeById && (nodeById.type === \\\"INSTANCE\\\" || nodeById.type === \\\"FRAME\\\")) {\\n          log(`Updating existing instance/frame by ID: ${nodeById.name}`);\\n          if (Array.isArray(spec.children)) {\\n            for (const c of spec.children) await createNode(c, nodeById);\\n          }\\n          continue;\\n        }\\n      }\\n      const target = figma.currentPage.findOne(\\n        (n) => n.name === spec.name && (n.type === \\\"INSTANCE\\\" || n.type === \\\"FRAME\\\")\\n      );\\n      if (target) {\\n        log(`Updating existing node by name: ${target.name}`);\\n        if (Array.isArray(spec.children)) {\\n          for (const c of spec.children) await createNode(c, target);\\n        }\\n        continue;\\n      }\\n      await createNode(spec, figma.currentPage);\\n    }\\n    ok(`Created or updated ${nodeMap.size} nodes total`);\\n  }\\n  async function retiePageToVariables() {\\n    if (!figma.variables) {\\n      log(\\\"Variables API unavailable\\\");\\n      return;\\n    }\\n    const collections = await figma.variables.getLocalVariableCollectionsAsync();\\n    let vars = await figma.variables.getLocalVariablesAsync();\\n    if (!Array.isArray(vars)) vars = [];\\n    if (vars.length === 0) {\\n      for (const c of collections) {\\n        try {\\n          const got = await figma.variables.getVariablesInCollectionAsync(c.id);\\n          if (Array.isArray(got) && got.length) vars.push(...got);\\n        } catch (e) {\\n          log(`retie: getVariablesInCollectionAsync failed for \\\"${c.name}\\\": ${String(e)}`);\\n        }\\n      }\\n    }\\n    log(`retie: found ${collections.length} collections, ${vars.length} variables`);\\n    if (!collections.length || !vars.length) {\\n      ok(\\\"Re-tied 0 properties on this page\\\");\\n      return;\\n    }\\n    const varById = new Map(vars.map((v) => [v.id, v]));\\n    const colorIdx = /* @__PURE__ */ new Map();\\n    const numIdx = /* @__PURE__ */ new Map();\\n    const strIdx = /* @__PURE__ */ new Map();\\n    const round255 = (x) => Math.round((x != null ? x : 1) * 255);\\n    const keyRGBA = (r, g, b, a) => `${round255(r)},${round255(g)},${round255(b)},${round255(a != null ? a : 1)}`;\\n    const getVal = (v, modeId) => {\\n      try {\\n        if (typeof v.getValueForMode === \\\"function\\\") return v.getValueForMode(modeId);\\n        if (typeof v.getValueForModeId === \\\"function\\\") return v.getValueForModeId(modeId);\\n      } catch (_) {\\n      }\\n      if (v.valuesByMode && typeof v.valuesByMode === \\\"object\\\") {\\n        const val = v.valuesByMode[modeId];\\n        if (val !== void 0) return val;\\n      }\\n      return void 0;\\n    };\\n    for (const v of vars) {\\n      const col = collections.find((c) => c.id === v.variableCollectionId);\\n      if (!col) continue;\\n      for (const m of col.modes) {\\n        const val = getVal(v, m.modeId);\\n        if (val == null) continue;\\n        if (v.resolvedType === \\\"COLOR\\\" && typeof val === \\\"object\\\" && \\\"r\\\" in val) {\\n          const { r, g, b, a } = val;\\n          colorIdx.set(keyRGBA(r, g, b, a), { id: v.id, name: v.name });\\n        } else if (v.resolvedType === \\\"FLOAT\\\") {\\n          const n = Number(val);\\n          if (Number.isFinite(n)) numIdx.set(n, { id: v.id, name: v.name });\\n        } else if (v.resolvedType === \\\"STRING\\\") {\\n          strIdx.set(String(val), { id: v.id, name: v.name });\\n        }\\n      }\\n    }\\n    log(`indexed ${colorIdx.size} colors, ${numIdx.size} numbers, ${strIdx.size} strings`);\\n    const solidRGBA = (p) => {\\n      const a = typeof p.opacity === \\\"number\\\" ? p.opacity : 1;\\n      return { r: p.color.r, g: p.color.g, b: p.color.b, a };\\n    };\\n    const nodes = figma.currentPage.findAll();\\n    let bound = 0;\\n    function bindPaintColor(node, prop, varId) {\\n      const variable = varById.get(varId);\\n      if (!variable) {\\n        log(`WARN paint: missing var ${varId}`);\\n        return false;\\n      }\\n      const paints = node[prop];\\n      if (!Array.isArray(paints) || paints.length === 0) return false;\\n      const p0 = paints[0];\\n      if (p0.type !== \\\"SOLID\\\") return false;\\n      const newPaint = Object.assign({}, p0);\\n      const existingBV = p0.boundVariables || {};\\n      const nextBV = Object.assign({}, existingBV, {\\n        // ✅ REQUIRED SHAPE\\n        color: { type: \\\"VARIABLE_ALIAS\\\", id: variable.id }\\n      });\\n      newPaint.boundVariables = nextBV;\\n      const next = paints.slice();\\n      next[0] = newPaint;\\n      try {\\n        node[prop] = next;\\n        return true;\\n      } catch (e) {\\n        log(`bind ${prop} color failed: ${String(e)}`);\\n        return false;\\n      }\\n    }\\n    const bind = (node, prop, varId) => {\\n      const variable = varById.get(varId);\\n      if (!variable) return;\\n      try {\\n        node.setBoundVariable(prop, variable);\\n        bound++;\\n      } catch (e) {\\n        log(`bind ${prop} failed: ${String(e)}`);\\n      }\\n    };\\n    for (const node of nodes) {\\n      if (\\\"fills\\\" in node) {\\n        const fs = node.fills;\\n        if (Array.isArray(fs) && fs.length && fs[0].type === \\\"SOLID\\\") {\\n          const { r, g, b, a } = solidRGBA(fs[0]);\\n          const m = colorIdx.get(keyRGBA(r, g, b, a));\\n          if (m && bindPaintColor(node, \\\"fills\\\", m.id)) {\\n            bound++;\\n            log(`bind fills \\\\u2192 ${m.name}`);\\n          }\\n        }\\n      }\\n      if (\\\"strokes\\\" in node) {\\n        const st = node.strokes;\\n        if (Array.isArray(st) && st.length && st[0].type === \\\"SOLID\\\") {\\n          const { r, g, b, a } = solidRGBA(st[0]);\\n          const m = colorIdx.get(keyRGBA(r, g, b, a));\\n          if (m && bindPaintColor(node, \\\"strokes\\\", m.id)) {\\n            bound++;\\n            log(`bind strokes \\\\u2192 ${m.name}`);\\n          }\\n        }\\n      }\\n      if (node.type === \\\"TEXT\\\") {\\n        const t = node;\\n        if (typeof t.fontSize === \\\"number\\\") {\\n          const m = numIdx.get(t.fontSize);\\n          if (m) {\\n            bind(t, \\\"fontSize\\\", m.id);\\n            log(`bind fontSize \\\\u2192 ${m.name}`);\\n          }\\n        }\\n        const lh = t.lineHeight;\\n        if (lh && typeof lh === \\\"object\\\" && lh.unit === \\\"PIXELS\\\" && typeof lh.value === \\\"number\\\") {\\n          const m = numIdx.get(lh.value);\\n          if (m) {\\n            bind(t, \\\"lineHeight\\\", m.id);\\n            log(`bind lineHeight \\\\u2192 ${m.name}`);\\n          }\\n        }\\n        const tf = t.fills;\\n        if (Array.isArray(t.fills) && t.fills.length && t.fills[0].type === \\\"SOLID\\\") {\\n          const { r, g, b, a } = solidRGBA(t.fills[0]);\\n          const m = colorIdx.get(keyRGBA(r, g, b, a));\\n          if (m && bindPaintColor(t, \\\"fills\\\", m.id)) {\\n            bound++;\\n            log(`bind text fill \\\\u2192 ${m.name}`);\\n          }\\n        }\\n      }\\n      const n = node;\\n      const numericProps = [\\\"itemSpacing\\\", \\\"paddingLeft\\\", \\\"paddingRight\\\", \\\"paddingTop\\\", \\\"paddingBottom\\\", \\\"cornerRadius\\\", \\\"strokeWeight\\\"];\\n      for (const prop of numericProps) {\\n        if (typeof n[prop] === \\\"number\\\") {\\n          const m = numIdx.get(n[prop]);\\n          if (m) {\\n            bind(node, prop, m.id);\\n            log(`bind ${prop} \\\\u2192 ${m.name}`);\\n          }\\n        }\\n      }\\n    }\\n    ok(`Re-tied ${bound} properties on this page`);\\n  }\\n  log(\\\"YY Make Changes ready\\\");\\n  figma.notify(\\\"YY Make Changes plugin ready\\\");\\n})();\\n\"\n    },\n    {\n      \"name\": \"main-implement.ts\",\n      \"type\": \"file\",\n      \"content\": \"// main-implement.js\\n\\nconst uiLog = (text: string) => { try { figma.ui.postMessage({ type: \\\"log\\\", text }); } catch (_) { /* ignored */ } };\\nconst log = (...a) => { console.log(\\\"[YY-MakeChanges]\\\", ...a); uiLog(a.map(String).join(\\\" \\\")); };\\nconst ok = (m) => { figma.notify(`✅ ${m}`); uiLog(`✅ ${m}`); };\\nconst err = (m) => { figma.notify(`⚠️ ${m}`); uiLog(`⚠️ ${m}`); };\\nconst warn = msg => console.warn(`⚠️ ${msg}`);\\n\\n// ------------- Show UI -------------\\n\\nfigma.showUI(\\n    `<html><body style=\\\"margin:8px;font:12px ui-monospace,monospace\\\">\\n    <div id=out style=\\\"white-space:pre;max-width:460px;margin-bottom:6px\\\"></div>\\n    <label for=txt style=\\\"display:block;margin-bottom:4px;font-weight:600;\\\">Insert JSON:</label>\\n    <textarea id=txt rows=8 placeholder='{\\\"meta\\\": {...}, \\\"variables\\\": {...}, \\\"nodes\\\": [...] }'\\n      style=\\\"width:460px;max-width:460px;font:12px ui-monospace,monospace;white-space:pre\\\"></textarea><br/>\\n    <div style=\\\"margin-top:6px;display:flex;gap:6px\\\">\\n      <button id=apply>Apply JSON</button>\\n      <button id=retie>Re-tie page to variables</button>\\n    </div>\\n\\n    <script>\\n      const out = document.getElementById('out');\\n      const txt = document.getElementById('txt');\\n      const btnApply = document.getElementById('apply');\\n      const btnRetie = document.getElementById('retie');\\n      const log = (m) => out.textContent += (m + \\\"\\\\\\\\n\\\");\\n      window.onmessage = (e) => { const m = e.data.pluginMessage; if (m && m.type === 'log') log(m.text); };\\n\\n      btnApply.onclick = () => parent.postMessage({ pluginMessage:{ type:'apply-json', text: txt.value } }, '*');\\n      btnRetie.onclick  = () => parent.postMessage({ pluginMessage:{ type:'retie' } }, '*');\\n    </script>\\n  </body></html>`,\\n    { width: 500, height: 360 }\\n);\\n\\n// -------------------- Communications --------------------\\nfigma.ui.onmessage = async (msg) => {\\n    if (msg?.type === \\\"retie\\\") {\\n        await retiePageToVariables();\\n        return;\\n    }\\n    if (msg?.type !== \\\"apply-json\\\") return;\\n\\n    try {\\n        const raw = msg.text;\\n        const parsed = typeof raw === \\\"string\\\" ? JSON.parse(raw) : raw;\\n        const jsonfile = parseLoadedFile(parsed);\\n\\n        applyMeta(jsonfile.meta);\\n        await applyVariables(jsonfile.variables);\\n        await applyNodes(jsonfile.nodes);\\n\\n        ok(\\\"Changes applied\\\");\\n    } catch (e) {\\n        err(\\\"apply-json failed: \\\" + String((e as any)?.message ?? e));\\n    }\\n};\\n\\n\\n// -------------------- Pipeline --------------------\\n\\n    async function applyJSONFile(jsonfile: { schema:any; meta:any; variables:any; nodes:any; }) {\\n        applyMeta(jsonfile.meta);\\n        await applyVariables(jsonfile.variables, jsonfile.meta?.renameCollections); // ← pass map\\n        await applyNodes(jsonfile.nodes);\\n    }\\n\\n\\n// -------------------- Parsing / Normalization --------------------\\n\\n    function parseLoadedFile(obj: any) {\\n        if (!obj || typeof obj !== \\\"object\\\") throw new Error(\\\"JSON must be an object\\\");\\n        return {\\n            schema: obj[\\\"$schema\\\"] || null,\\n            meta: obj.meta || {},\\n            variables: obj.variables || { collectionsCount: 0, collections: [] },\\n            nodes: obj.nodes || null\\n        };\\n    }\\n\\n        // -------------------- Meta --------------------\\n\\n        function applyMeta(meta: any = {}) {\\n            try {\\n                // store what we can at document scope\\n                if (meta.fileName) figma.root.setPluginData(\\\"yy_desiredFileName\\\", String(meta.fileName)); // cannot actually rename file\\n                if (meta.scanId)   figma.root.setPluginData(\\\"yy_scanId\\\",       String(meta.scanId));\\n                if (meta.pageName) figma.root.setPluginData(\\\"yy_pageName\\\",     String(meta.pageName));\\n                if (meta.author)   figma.root.setPluginData(\\\"yy_author\\\",       String(meta.author));\\n                if (meta.version)  figma.root.setPluginData(\\\"yy_version\\\",      String(meta.version));\\n\\n                // optional shared plugin data (namespaced) for team-wide visibility\\n                try {\\n                    const NS = \\\"yy\\\";\\n                    Object.entries(meta).forEach(([k,v]) => { if (v != null) figma.root.setSharedPluginData(NS, k, String(v)); });\\n                } catch {}\\n\\n                const desired = figma.root.getPluginData(\\\"yy_desiredFileName\\\");\\n                if (desired) ok(`Please rename this file to: ${desired} (plugins can’t rename files)`);\\n                log(\\\"Meta saved: \\\" + JSON.stringify({ fileName: meta.fileName, scanId: meta.scanId, pageName: meta.pageName, author: meta.author, version: meta.version }));\\n            } catch (e) { err(\\\"applyMeta: \\\" + String(e)); }\\n        }\\n\\n        // -------------------- Variables (collections only, correct API) --------------------\\n        // Note: variable APIs differ between plugin runtime versions. We feature-detect and keep things safe.\\n\\n        async function applyVariables(variables: any = { collections: [] }) {\\n            try {\\n                if (!figma.variables) { log(\\\"Variable API unavailable\\\"); return; }\\n                const cols = Array.isArray(variables?.collections) ? variables.collections : [];\\n                if (!cols.length) { log(\\\"No variable collections to apply\\\"); return; }\\n\\n                const TYPE: Record<string, VariableResolvedDataType> = {\\n                    COLOR: \\\"COLOR\\\", FLOAT: \\\"FLOAT\\\", STRING: \\\"STRING\\\", BOOLEAN: \\\"BOOLEAN\\\", NUMBER: \\\"FLOAT\\\"\\n                };\\n\\n                const localCollections = await figma.variables.getLocalVariableCollectionsAsync();\\n                const collectionByName = new Map(localCollections.map(c => [c.name, c]));\\n\\n                for (const c of cols) {\\n                    const name = String(c?.name || \\\"\\\").trim();\\n                    if (!name) { log(\\\"Skip unnamed collection\\\"); continue; }\\n\\n                    // 1) ensure collection\\n                    let collection = collectionByName.get(name);\\n                    // Handle renames first\\n                    if (!collection) {\\n                        collection = figma.variables.createVariableCollection(name);\\n                        collectionByName.set(name, collection);\\n                        log(`Created collection: \\\"${name}\\\" (${collection.id})`);\\n                    } else {\\n                        log(`Collection exists: \\\"${name}\\\"`);\\n                    }\\n\\n                    // 2) ensure modes (on the collection)\\n                    const wantModes = (Array.isArray(c?.modes) ? c.modes : []).map((m:any)=>String(m?.name||\\\"\\\").trim()).filter(Boolean);\\n                    if (wantModes.length) {\\n                        // if collection has a single default mode, rename it to the first desired mode\\n                        if (collection.modes.length === 1 && collection.modes[0].name !== wantModes[0]) {\\n                            collection.renameMode(collection.modes[0].modeId, wantModes[0]);\\n                            log(`  • renamed default mode → ${wantModes[0]}`);\\n                        }\\n                        // add any missing modes\\n                        for (const m of wantModes) {\\n                            if (!collection.modes.find(x => x.name === m)) {\\n                                collection.addMode(m);\\n                                log(`  • added mode: ${m}`);\\n                            }\\n                        }\\n                    } else if (!collection.modes.length) {\\n                        collection.addMode(\\\"Base\\\");\\n                    }\\n\\n                    // refresh mode map\\n                    const modeIdByName = new Map(collection.modes.map(m => [m.name, m.modeId]));\\n\\n                    // 3) variables\\n                    const wantVars = Array.isArray(c?.variables) ? c.variables : [];\\n                    if (!wantVars.length) { log(`  (no variables in \\\"${name}\\\")`); continue; }\\n\\n                    const localVars = (await figma.variables.getLocalVariablesAsync())\\n                        .filter(v => v.variableCollectionId === collection.id);\\n                    const varByName = new Map(localVars.map(v => [v.name, v]));\\n\\n                    for (const v of wantVars) {\\n                        const vName = String(v?.name || \\\"\\\").trim(); if (!vName) { log(\\\"  - skip unnamed variable\\\"); continue; }\\n                        const vType = TYPE[String(v?.type || \\\"\\\").toUpperCase()] ?? \\\"STRING\\\";\\n                        const valuesByMode = (v?.valuesByMode && typeof v.valuesByMode === \\\"object\\\") ? v.valuesByMode : {};\\n\\n                        // create or recreate if type mismatch\\n                        let variable = varByName.get(vName);\\n                        if (!variable) {\\n                            variable = figma.variables.createVariable(vName, collection.id, vType);\\n                            varByName.set(vName, variable);\\n                            log(`  + var: ${vName} (${vType})`);\\n                        } else if (variable.resolvedType !== vType) {\\n                            log(`  ! type mismatch for ${vName} (have ${variable.resolvedType}, want ${vType}) — recreating`);\\n                            variable.remove();\\n                            variable = figma.variables.createVariable(vName, collection.id, vType);\\n                            varByName.set(vName, variable);\\n                        } else {\\n                            log(`  = var: ${vName}`);\\n                        }\\n\\n                        // set values per mode\\n                        for (const [modeName, raw] of Object.entries(valuesByMode)) {\\n                            const modeId = modeIdByName.get(modeName);\\n                            if (!modeId) { log(`    • mode \\\"${modeName}\\\" not found in \\\"${name}\\\"`); continue; }\\n\\n                            try {\\n                                let val: any = raw;\\n                                if (vType === \\\"COLOR\\\") {\\n                                    const { r, g, b, a } = hexToRgb01(String(raw).trim());\\n                                    val = { r, g, b, a }; // RGBA in 0–1 (what Variables expect)\\n                                } else if (vType === \\\"FLOAT\\\") {\\n                                    val = Number(raw);\\n                                } else if (vType === \\\"BOOLEAN\\\") {\\n                                    val = Boolean(raw);\\n                                } else {\\n                                    val = String(raw);\\n                                }\\n                                variable.setValueForMode(modeId, val);\\n                                log(`    • set ${vName} @ ${modeName}`);\\n                            } catch (e) {\\n                                err(`    set ${vName} @ ${modeName}: ${String(e)}`);\\n                            }\\n                        }\\n                    }\\n                }\\n            } catch (e) {\\n                err(\\\"applyVariables: \\\" + String(e));\\n            }\\n        }\\n\\n        // helper\\n        function hexToRgb01(hex: string){ const h=hex.replace(\\\"#\\\",\\\"\\\").trim();\\n            let r=0,g=0,b=0,a=1; if(h.length===3){r=parseInt(h[0]+h[0],16);g=parseInt(h[1]+h[1],16);b=parseInt(h[2]+h[2],16);}\\n            else if(h.length===6){r=parseInt(h.slice(0,2),16);g=parseInt(h.slice(2,4),16);b=parseInt(h.slice(4,6),16);}\\n            else if(h.length===8){r=parseInt(h.slice(0,2),16);g=parseInt(h.slice(2,4),16);b=parseInt(h.slice(4,6),16);a=parseInt(h.slice(6,8),16)/255;}\\n            return { r:r/255,g:g/255,b:b/255,a };\\n        }\\n\\n\\n\\n        // -------------------- Nodes --------------------\\n        async function applyNodes(nodes: any) {\\n            if (!nodes) return log(\\\"No changes found\\\");\\n\\n            const arr = Array.isArray(nodes) ? nodes : [nodes];\\n            const nodeMap = new Map<string, SceneNode>();\\n            const componentMap = new Map<string, ComponentNode>();\\n\\n            async function createNode(spec: any, parent?: BaseNode & ChildrenMixin): Promise<BaseNode | null> {\\n                const t = (spec?.type || spec?.kind || \\\"\\\").toUpperCase();\\n                // --- SAFETY: never edit component masters directly ---\\n                if (spec.id) {\\n                    const node = figma.getNodeById(spec.id);\\n                    if (node && node.type === \\\"COMPONENT\\\" && !node.mainComponent) {\\n                        log(`⛔ Skipping component master: ${node.name}`);\\n                        return null;\\n                    }\\n                    }\\n\\n                let node: SceneNode | null = null;\\n\\n                try {\\n                    switch (t) {\\n\\n                        // ──────────────────────────── FRAME UPDATE ────────────────────────────\\n                        case \\\"FRAME\\\":\\n                        case \\\"FRAME-SNAPSHOT\\\": {\\n                            const id = spec?.id;\\n                            if (!id) { log(\\\"frame-snapshot missing id\\\"); break; }\\n\\n                            const existing = figma.getNodeById(id);\\n                            if (existing.type !== \\\"FRAME\\\" && existing.type !== \\\"INSTANCE\\\") {\\n                                log(`Node ${id} not a FRAME or INSTANCE — skipped`);\\n                                break;\\n                            }\\n\\n                            const f = existing as FrameNode;\\n                            const p = spec.absPos, s = spec.size;\\n\\n                            if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) {\\n                                f.x = p.x; f.y = p.y;\\n                                log(`pos → ${p.x},${p.y}`);\\n                            }\\n                            if (s && Number.isFinite(s.w) && Number.isFinite(s.h)) {\\n                                f.resize(s.w, s.h);\\n                                log(`size → ${s.w}×${s.h}`);\\n                            }\\n                            ok(`Frame updated: ${f.name}`);\\n\\n                            if (Array.isArray(spec.children)) {\\n                                for (const child of spec.children) {\\n                                    await createNode(child, f);\\n                                }\\n                            }\\n                            break;\\n                        }\\n\\n                        // ──────────────────────────── INSTANCE UPDATE ────────────────────────────\\n                        // -------------------- Instance Update (for swatch palettes) --------------------\\n                        case \\\"INSTANCE-UPDATE\\\": {\\n                            const name = String(spec?.name || \\\"\\\").trim();\\n                            if (!name) { log(\\\"Instance-update missing name\\\"); break; }\\n\\n                            // Find the instance node by name\\n                            const inst = figma.currentPage.findOne(\\n                                n => n.name === name && (n.type === \\\"INSTANCE\\\" || n.type === \\\"FRAME\\\")\\n                            ) as InstanceNode | FrameNode | null;\\n\\n                            if (!inst) { warn(`Instance \\\"${name}\\\" not found`); break; }\\n\\n                            // --- Skip master components to avoid overwriting them ---\\n                            if (inst.type === \\\"COMPONENT\\\") {\\n                                log(`⏭️ Skipping master component: ${name}`);\\n                                break;\\n                            }\\n\\n                            // --- Update the color rectangle fill ---\\n                            let colorRect: RectangleNode | null = null;\\n                            try {\\n                                colorRect = inst.findOne(n => n.name === \\\"ColorBox\\\") as RectangleNode | null;\\n                                if (colorRect) {\\n                                    // Apply solid color if Hex provided\\n                                    if (spec.Hex) {\\n                                        const { r, g, b, a } = hexToRgb01(spec.Hex);\\n                                        colorRect.fills = [{ type: \\\"SOLID\\\", color: { r, g, b }, opacity: a }];\\n                                        log(`🎨 Updated fill color for ${name}`);\\n                                    }\\n\\n                                    // --- Bind Variable if specified ---\\n                                    if (spec.variableAlias) {\\n                                        try {\\n                                            const variable = figma.variables.getVariableById(spec.variableAlias);\\n                                            if (variable) {\\n                                                colorRect.boundVariables = {\\n                                                    fills: { type: \\\"VARIABLE_ALIAS\\\", id: variable.id }\\n                                                };\\n                                                log(`✅ Bound ${name} fill to variable: ${variable.name}`);\\n                                            } else {\\n                                                warn(`⚠️ Variable not found: ${spec.variableAlias}`);\\n                                            }\\n                                        } catch (e) {\\n                                            warn(`⚠️ Failed to bind variable for ${name}: ${String(e)}`);\\n                                        }\\n                                    }\\n                                } else {\\n                                    warn(`No \\\"ColorBox\\\" found inside ${name}`);\\n                                }\\n                            } catch (e) {\\n                                err(`Failed to recolor ${name}: ${String(e)}`);\\n                            }\\n\\n                            // --- Update text layers (Label + Hex) ---\\n                            try {\\n                                const label = inst.findOne(n => n.name === \\\"Label\\\") as TextNode | null;\\n                                if (label && spec.Label) {\\n                                    await figma.loadFontAsync(label.fontName as FontName);\\n                                    label.characters = spec.Label;\\n                                }\\n\\n                                const hexText = inst.findOne(n => n.name === \\\"Hex\\\") as TextNode | null;\\n                                if (hexText && spec.Hex) {\\n                                    await figma.loadFontAsync(hexText.fontName as FontName);\\n                                    hexText.characters = spec.Hex;\\n                                }\\n\\n                                log(`📝 Updated text for ${name}`);\\n                            } catch (e) {\\n                                warn(`⚠️ Text update failed in ${name}: ${String(e)}`);\\n                            }\\n\\n                            updatedCount++;\\n                            break;\\n                        }\\n\\n\\n                        // ──────────────────────────── INSTANCE CREATION ────────────────────────────\\n                        case \\\"INSTANCE\\\": {\\n                            try {\\n                                const componentId = String(spec?.componentId || \\\"\\\").trim();\\n                                if (!componentId) { log(\\\"Instance missing componentId\\\"); break; }\\n\\n                                // Find the component in the document\\n                                const comp = figma.getNodeById(componentId) as ComponentNode | null;\\n                                if (!comp) { log(`Component not found for id: ${componentId}`); break; }\\n\\n                                // Create the instance\\n                                const inst = comp.createInstance();\\n                                if (spec.name) inst.name = spec.name;\\n\\n                                // Optional positioning\\n                                if (spec.absPos) { inst.x = spec.absPos.x || 0; inst.y = spec.absPos.y || 0; }\\n                                if (spec.size) inst.resize(spec.size.w || inst.width, spec.size.h || inst.height);\\n\\n                                // Optional auto layout configuration\\n                                if (spec.autoLayout) {\\n                                    const f = inst as FrameNode;\\n                                    f.layoutMode = spec.autoLayout.direction === \\\"VERTICAL\\\" ? \\\"VERTICAL\\\" : \\\"HORIZONTAL\\\";\\n                                    f.itemSpacing = spec.autoLayout.spacing ?? 8;\\n                                    f.paddingLeft = f.paddingRight = f.paddingTop = f.paddingBottom = spec.autoLayout.padding ?? 0;\\n                                }\\n\\n                                // Attach to current page\\n                                figma.currentPage.appendChild(inst);\\n\\n                                ok(`Created instance: ${inst.name}`);\\n                            } catch (e) {\\n                                err(`createInstance: ${String(e)}`);\\n                            }\\n                            break;\\n                        }\\n\\n                        // ──────────────────────────── UNKNOWN / UNSUPPORTED ────────────────────────────\\n                        default:\\n                            err(`Unknown node type: ${t} — skipped (no fallback creation)`);\\n                            break;\\n                    }\\n\\n                    // shared property updates (for newly created or updated nodes)\\n                    if (node && spec.name) node.name = spec.name;\\n                    if (node && spec.size) node.resize(spec.size.w || node.width, spec.size.h || node.height);\\n                    if (node && spec.absPos) { node.x = spec.absPos.x || 0; node.y = spec.absPos.y || 0; }\\n\\n                    // auto layout\\n                    if (node && spec.autoLayout) {\\n                        const f = node as FrameNode | ComponentNode;\\n                        f.layoutMode = spec.autoLayout.direction === \\\"VERTICAL\\\" ? \\\"VERTICAL\\\" : \\\"HORIZONTAL\\\";\\n                        f.itemSpacing = spec.autoLayout.spacing ?? 8;\\n                        f.paddingLeft = f.paddingRight = f.paddingTop = f.paddingBottom = spec.autoLayout.padding ?? 0;\\n                    }\\n\\n                    // solid fill (if explicitly given)\\n                    if (node && spec.fill) {\\n                        const { r, g, b, a } = hexToRgb01(spec.fill);\\n                        (node as GeometryMixin).fills = [{ type: \\\"SOLID\\\", color: { r, g, b }, opacity: a }];\\n                    }\\n\\n                    // recurse into children\\n                    if (node && Array.isArray(spec.children)) {\\n                        for (const child of spec.children) await createNode(child, node as BaseNode & ChildrenMixin);\\n                    }\\n\\n                    // store references\\n                    if (node && spec.id) nodeMap.set(spec.id, node);\\n                    if (node && t === \\\"COMPONENT\\\" && spec.id) componentMap.set(spec.id, node as ComponentNode);\\n\\n                    if (node) ok(`Created or updated ${t}: ${spec.name || \\\"(unnamed)\\\"}`);\\n                    return node;\\n\\n                } catch (e) {\\n                    err(`createNode(${spec?.name || t}): ${String(e)}`);\\n                    return null;\\n                }\\n            }\\n\\n            // ──────────────────────────── Main Loop ────────────────────────────\\n            for (const spec of arr) {\\n                // 🔒 Skip master components even if the JSON includes their ID\\n                if (spec.id) {\\n                    const nodeById = figma.getNodeById(spec.id);\\n                    if (nodeById && nodeById.type === \\\"COMPONENT\\\" && !nodeById.mainComponent) {\\n                        log(`⛔ Skipping main component for id ${spec.id}`);\\n                        continue;\\n                    }\\n\\n                    // ✅ Safe path for instances or frames\\n                    if (nodeById && (nodeById.type === \\\"INSTANCE\\\" || nodeById.type === \\\"FRAME\\\")) {\\n                        log(`Updating existing instance/frame by ID: ${nodeById.name}`);\\n                        if (Array.isArray(spec.children)) {\\n                            for (const c of spec.children) await createNode(c, nodeById);\\n                        }\\n                        continue;\\n                    }\\n                }\\n\\n                // Fallback by name if ID not found\\n                const target = figma.currentPage.findOne(\\n                    n => n.name === spec.name && (n.type === \\\"INSTANCE\\\" || n.type === \\\"FRAME\\\")\\n                );\\n                if (target) {\\n                    log(`Updating existing node by name: ${target.name}`);\\n                    if (Array.isArray(spec.children)) {\\n                        for (const c of spec.children) await createNode(c, target);\\n                    }\\n                    continue;\\n                }\\n\\n                await createNode(spec, figma.currentPage);\\n            }\\n\\n\\n            ok(`Created or updated ${nodeMap.size} nodes total`);\\n        }\\n\\n\\n\\n// -------------------------------- Re-tie page to Variables --------------------------------\\nasync function retiePageToVariables() {\\n    if (!figma.variables) { log(\\\"Variables API unavailable\\\"); return; }\\n\\n    // --- setup ---\\n    // 1) collections (local only)\\n    const collections = await figma.variables.getLocalVariableCollectionsAsync();\\n\\n    // 2) variables: try local first, then per-collection fallback\\n    let vars: Variable[] = await figma.variables.getLocalVariablesAsync();  // single declaration\\n    if (!Array.isArray(vars)) vars = [];\\n    if (vars.length === 0) {\\n        // fallback: gather variables from each local collection\\n        for (const c of collections) {\\n            try {\\n                const got = await figma.variables.getVariablesInCollectionAsync(c.id);\\n                if (Array.isArray(got) && got.length) vars.push(...got);\\n            } catch (e) {\\n                log(`retie: getVariablesInCollectionAsync failed for \\\"${c.name}\\\": ${String(e)}`);\\n            }\\n        }\\n    }\\n\\n    log(`retie: found ${collections.length} collections, ${vars.length} variables`);\\n\\n    // quick exits to avoid doing work if truly empty\\n    if (!collections.length || !vars.length) {\\n        ok(\\\"Re-tied 0 properties on this page\\\");\\n        return;\\n    }\\n\\n    // lookups (for binding)\\n    const varById     = new Map(vars.map(v => [v.id, v]));\\n\\n    // indexes must exist here so both indexer + binder can see them\\n    const colorIdx = new Map<string, { id:string; name:string }>();\\n    const numIdx   = new Map<number, { id:string; name:string }>();\\n    const strIdx   = new Map<string, { id:string; name:string }>();\\n\\n    // tolerant color key\\n    const round255 = (x: number) => Math.round((x ?? 1) * 255);\\n    const keyRGBA  = (r:number,g:number,b:number,a:number) =>\\n        `${round255(r)},${round255(g)},${round255(b)},${round255(a ?? 1)}`;\\n\\n    // API compatibility: old vs new\\n    const getVal = (v: any, modeId: string) => {\\n        try {\\n            if (typeof v.getValueForMode === \\\"function\\\") return v.getValueForMode(modeId);\\n            if (typeof v.getValueForModeId === \\\"function\\\") return v.getValueForModeId(modeId);\\n        } catch (_) { /* ignore */ }\\n\\n        // 🔧 fallback: read from valuesByMode object (some builds require this)\\n        if (v.valuesByMode && typeof v.valuesByMode === \\\"object\\\") {\\n            const val = v.valuesByMode[modeId];\\n            if (val !== undefined) return val;\\n        }\\n\\n        return undefined;\\n    };\\n\\n    // Index every variable for all modes in its collection\\n    for (const v of vars) {\\n        const col = collections.find(c => c.id === v.variableCollectionId);\\n        if (!col) continue;\\n        for (const m of col.modes) {\\n            const val = getVal(v, m.modeId);\\n            if (val == null) continue;\\n            if (v.resolvedType === \\\"COLOR\\\" && typeof val === \\\"object\\\" && \\\"r\\\" in val) {\\n                const {r,g,b,a} = val as {r:number;g:number;b:number;a:number};\\n                colorIdx.set(keyRGBA(r,g,b,a), {id:v.id, name:v.name});\\n            } else if (v.resolvedType === \\\"FLOAT\\\") {\\n                const n = Number(val);\\n                if (Number.isFinite(n)) numIdx.set(n, {id:v.id, name:v.name});\\n            } else if (v.resolvedType === \\\"STRING\\\") {\\n                strIdx.set(String(val), {id:v.id, name:v.name});\\n            }\\n        }\\n    }\\n\\n    log(`indexed ${colorIdx.size} colors, ${numIdx.size} numbers, ${strIdx.size} strings`);\\n\\n    // --- walk nodes + bind ---\\n    const solidRGBA = (p: SolidPaint) => {\\n        const a = typeof p.opacity === \\\"number\\\" ? p.opacity : 1;\\n        return {r:p.color.r, g:p.color.g, b:p.color.b, a};\\n    };\\n    const nodes = figma.currentPage.findAll();\\n    let bound = 0;\\n\\n    function bindPaintColor(node: any, prop: \\\"fills\\\" | \\\"strokes\\\", varId: string) {\\n        const variable = varById.get(varId);\\n        if (!variable) { log(`WARN paint: missing var ${varId}`); return false; }\\n\\n        const paints = node[prop] as ReadonlyArray<Paint>;\\n        if (!Array.isArray(paints) || paints.length === 0) return false;\\n\\n        const p0 = paints[0];\\n        if (p0.type !== \\\"SOLID\\\") return false;\\n\\n        // clone paint without spread\\n        const newPaint: SolidPaint = Object.assign({}, p0) as SolidPaint;\\n\\n        // keep existing boundVariables (if any) without spread\\n        const existingBV: any = (p0 as any).boundVariables || {};\\n        const nextBV: any = Object.assign({}, existingBV, {\\n            // ✅ REQUIRED SHAPE\\n            color: { type: \\\"VARIABLE_ALIAS\\\", id: variable.id }\\n        });\\n\\n        (newPaint as any).boundVariables = nextBV;\\n\\n        // write back paints (replace index 0) without spread\\n        const next = paints.slice();\\n        next[0] = newPaint;\\n\\n        try {\\n            (node as any)[prop] = next;\\n            return true;\\n        } catch (e) {\\n            log(`bind ${prop} color failed: ${String(e)}`);\\n            return false;\\n        }\\n    }\\n\\n    const bind = (node:any, prop:string, varId:string) => {\\n        const variable = varById.get(varId);\\n        if (!variable) return;\\n        try { node.setBoundVariable(prop, variable); bound++; }\\n        catch(e){ log(`bind ${prop} failed: ${String(e)}`); }\\n    };\\n\\n    for (const node of nodes) {\\n        // fills\\n        if (\\\"fills\\\" in node) {\\n            const fs = (node as GeometryMixin).fills;\\n            if (Array.isArray(fs) && fs.length && fs[0].type === \\\"SOLID\\\") {   // ← changed\\n                const { r,g,b,a } = solidRGBA(fs[0] as SolidPaint);\\n                const m = colorIdx.get(keyRGBA(r,g,b,a));\\n                if (m && bindPaintColor(node, \\\"fills\\\", m.id)) { bound++; log(`bind fills → ${m.name}`); }\\n            }\\n        }\\n\\n        // strokes\\n        if (\\\"strokes\\\" in node) {\\n            const st = (node as GeometryMixin).strokes;\\n            if (Array.isArray(st) && st.length && st[0].type === \\\"SOLID\\\") {   // ← changed\\n                const { r,g,b,a } = solidRGBA(st[0] as SolidPaint);\\n                const m = colorIdx.get(keyRGBA(r,g,b,a));\\n                if (m && bindPaintColor(node, \\\"strokes\\\", m.id)) { bound++; log(`bind strokes → ${m.name}`); }\\n            }\\n        }\\n\\n        // text\\n        if (node.type === \\\"TEXT\\\") {\\n            const t = node as TextNode;\\n            if (typeof t.fontSize === \\\"number\\\") {\\n                const m = numIdx.get(t.fontSize); if (m) { bind(t, \\\"fontSize\\\", m.id); log(`bind fontSize → ${m.name}`); }\\n            }\\n            const lh: any = t.lineHeight;\\n            if (lh && typeof lh === \\\"object\\\" && lh.unit === \\\"PIXELS\\\" && typeof lh.value === \\\"number\\\") {\\n                const m = numIdx.get(lh.value); if (m) { bind(t, \\\"lineHeight\\\", m.id); log(`bind lineHeight → ${m.name}`); }\\n            }\\n            const tf = t.fills as ReadonlyArray<Paint>;\\n            if (Array.isArray(t.fills) && t.fills.length && t.fills[0].type === \\\"SOLID\\\") {\\n                const { r,g,b,a } = solidRGBA(t.fills[0] as SolidPaint);\\n                const m = colorIdx.get(keyRGBA(r,g,b,a));\\n                if (m && bindPaintColor(t, \\\"fills\\\", m.id)) { bound++; log(`bind text fill → ${m.name}`); }\\n            }\\n        }\\n        // layout numerics\\n        const n:any = node;\\n        const numericProps = [\\\"itemSpacing\\\",\\\"paddingLeft\\\",\\\"paddingRight\\\",\\\"paddingTop\\\",\\\"paddingBottom\\\",\\\"cornerRadius\\\",\\\"strokeWeight\\\"];\\n        for (const prop of numericProps) {\\n            if (typeof n[prop] === \\\"number\\\") {\\n                const m = numIdx.get(n[prop]); if (m) { bind(node, prop, m.id); log(`bind ${prop} → ${m.name}`); }\\n            }\\n        }\\n    }\\n\\n    ok(`Re-tied ${bound} properties on this page`);\\n}\\n\\n\\n\\n\\n\\n// ready\\n\\nlog(\\\"YY Make Changes ready\\\");\\nfigma.notify(\\\"YY Make Changes plugin ready\\\");\\n\"\n    },\n    {\n      \"name\": \"manifest.json\",\n      \"type\": \"file\",\n      \"content\": \"{\\n  \\\"name\\\": \\\"YY Figma Assistant — Implement\\\",\\n  \\\"id\\\": \\\"yyfa-implement\\\",\\n  \\\"api\\\": \\\"1.0.0\\\",\\n  \\\"editorType\\\": [\\\"figma\\\"],\\n  \\\"main\\\": \\\"main-implement.js\\\",\\n  \\\"enableProposedApi\\\": true\\n}\\n\"\n    },\n    {\n      \"name\": \"package.json\",\n      \"type\": \"file\",\n      \"content\": \"{\\n  \\\"scripts\\\": {\\n    \\\"b\\\": \\\"esbuild main-implement.ts --outfile=main-implement.js --format=iife --platform=browser --target=es2018\\\"\\n  }\\n}\"\n    }\n  ]\n}"
    }
  ]
}
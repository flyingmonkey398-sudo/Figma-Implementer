{
  "name": "Figma-Plugin-YY-Assistant",
  "type": "folder",
  "children": [
    {
      "name": ".DS_Store",
      "type": "file",
      "content": null
    },
    {
      "name": ".gitignore",
      "type": "file",
      "content": null
    },
    {
      "name": "main-implement.js",
      "type": "file",
      "content": "const uiLog = (text) => {\n  try {\n    figma.ui.postMessage({ type: \"log\", text });\n  } catch (_) {\n  }\n};\nconst log = (...a) => {\n  console.log(\"[YY-MakeChanges]\", ...a);\n  uiLog(a.map(String).join(\" \"));\n};\nconst ok = (m) => {\n  figma.notify(`\\u2705 ${m}`);\n  uiLog(`\\u2705 ${m}`);\n};\nconst err = (m) => {\n  figma.notify(`\\u26A0\\uFE0F ${m}`);\n  uiLog(`\\u26A0\\uFE0F ${m}`);\n};\nfigma.showUI(\n  `<html><body style=\"margin:8px;font:12px ui-monospace,monospace\">\n<div id=out style=\"white-space:pre;max-width:380px\"></div>\n<button id=ok>Apply changes</button>\n<script>\n  const out=document.getElementById('out');\n  const log=(m)=>out.textContent+=m+\"\\\\n\";\n  onmessage=(e)=>{const msg=e.data.pluginMessage; if(msg?.type==='log') log(msg.text); };\n  document.getElementById('ok').onclick=()=>parent.postMessage({pluginMessage:{type:'apply-confirm'}},'*');\n<\\/script></body></html>`,\n  { width: 420, height: 140 }\n);\nfigma.ui.onmessage = async (msg) => {\n  var _a;\n  if ((msg == null ? void 0 : msg.type) !== \"apply-json\") return;\n  try {\n    const raw = msg.text;\n    const parsed = typeof raw === \"string\" ? JSON.parse(raw) : raw;\n    const jsonfile = parseLoadedFile(parsed);\n    applyMeta(jsonfile.meta);\n    await applyVariables(jsonfile.variables);\n    await applyNodes(jsonfile.nodes);\n    ok(\"Changes applied\");\n  } catch (e) {\n    err(\"apply-json failed: \" + String((_a = e == null ? void 0 : e.message) != null ? _a : e));\n  }\n};\nasync function applyJSONFile(jsonfile) {\n  applyMeta(jsonfile.meta);\n  await applyVariables(jsonfile.variables);\n  await applyNodes(jsonfile.nodes);\n}\nfunction parseLoadedFile(obj) {\n  if (!obj || typeof obj !== \"object\") throw new Error(\"JSON must be an object\");\n  return {\n    schema: obj[\"$schema\"] || null,\n    meta: obj.meta || {},\n    variables: obj.variables || { collectionsCount: 0, collections: [] },\n    nodes: obj.nodes || null\n  };\n}\nfunction applyMeta(meta = {}) {\n  try {\n    if (meta.fileName) figma.root.setPluginData(\"yy_desiredFileName\", String(meta.fileName));\n    if (meta.scanId) figma.root.setPluginData(\"yy_scanId\", String(meta.scanId));\n    if (meta.pageName) figma.root.setPluginData(\"yy_pageName\", String(meta.pageName));\n    if (meta.author) figma.root.setPluginData(\"yy_author\", String(meta.author));\n    if (meta.version) figma.root.setPluginData(\"yy_version\", String(meta.version));\n    try {\n      const NS = \"yy\";\n      Object.entries(meta).forEach(([k, v]) => {\n        if (v != null) figma.root.setSharedPluginData(NS, k, String(v));\n      });\n    } catch (e) {\n    }\n    const desired = figma.root.getPluginData(\"yy_desiredFileName\");\n    if (desired) ok(`Please rename this file to: ${desired} (plugins can\\u2019t rename files)`);\n    log(\"Meta saved: \" + JSON.stringify({ fileName: meta.fileName, scanId: meta.scanId, pageName: meta.pageName, author: meta.author, version: meta.version }));\n  } catch (e) {\n    err(\"applyMeta: \" + String(e));\n  }\n}\nasync function applyVariables(variables = { collectionsCount: 0, collections: [] }) {\n  var _a;\n  try {\n    const list = Array.isArray(variables == null ? void 0 : variables.collections) ? variables.collections : [];\n    if (list.length === 0 || !figma.variables) {\n      log(\"No variable collections to apply or API unavailable\");\n      return;\n    }\n    const existing = await figma.variables.getLocalVariableCollectionsAsync();\n    const byName = new Map(existing.map((c) => [c.name, c]));\n    for (const c of list) {\n      const name = ((_a = c == null ? void 0 : c.name) != null ? _a : \"\").trim();\n      if (!name) {\n        log(\"Skip unnamed collection\");\n        continue;\n      }\n      if (byName.has(name)) {\n        log(`Collection exists: \"${name}\"`);\n        continue;\n      }\n      const created = figma.variables.createVariableCollection(name);\n      log(`Created collection: \"${name}\" (${created.id})`);\n    }\n  } catch (e) {\n    err(\"applyVariables: \" + String(e));\n  }\n}\nasync function applyNodes(nodes) {\n  if (!nodes) return log(\"No changes found\");\n  const arr = Array.isArray(nodes) ? nodes : [nodes];\n  for (const n of arr) {\n    const t = (n == null ? void 0 : n.type) || (n == null ? void 0 : n.kind);\n    switch (t) {\n      case \"frame-snapshot\":\n      case void 0:\n        {\n          const id = n == null ? void 0 : n.id;\n          if (!id) {\n            log(\"frame-snapshot missing id\");\n            break;\n          }\n          const node = figma.getNodeById(id);\n          if (!node) {\n            log(`Node ${id} not found`);\n            break;\n          }\n          if (node.type !== \"FRAME\") {\n            log(`Node ${id} not a FRAME \\u2014 skip`);\n            break;\n          }\n          try {\n            const f = node;\n            const p = n.absPos, s = n.size;\n            if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) {\n              f.x = p.x;\n              f.y = p.y;\n              log(`pos \\u2192 ${p.x},${p.y}`);\n            }\n            if (s && Number.isFinite(s.w) && Number.isFinite(s.h)) {\n              f.resize(s.w, s.h);\n              log(`size \\u2192 ${s.w}\\xD7${s.h}`);\n            }\n            ok(`Frame updated: ${f.name}`);\n          } catch (e) {\n            err(\"frame update: \" + String(e));\n          }\n        }\n        break;\n      // ready for later, still inline if you want minimal footprint:\n      case \"text-style\":\n        log(`(todo) text-style change for ${n.id || n.name || \"node\"}`);\n        break;\n      case \"prototype-link\":\n        log(`(todo) prototype-link change for ${n.id || n.name || \"node\"}`);\n        break;\n      default:\n        log(`Unknown node type: ${t}`);\n    }\n  }\n}\nlog(\"YY MakeChanges ready\");\nfigma.notify(\"YY Make Changes plugin ready\");\n"
    },
    {
      "name": "main-implement.ts",
      "type": "file",
      "content": "// main-implement.js\n\nconst uiLog = (text: string) => { try { figma.ui.postMessage({ type: \"log\", text }); } catch (_) { /* ignored */ } };\nconst log = (...a) => { console.log(\"[YY-MakeChanges]\", ...a); uiLog(a.map(String).join(\" \")); };\nconst ok = (m) => { figma.notify(`✅ ${m}`); uiLog(`✅ ${m}`); };\nconst err = (m) => { figma.notify(`⚠️ ${m}`); uiLog(`⚠️ ${m}`); };\n\n\n// ------------- Show UI -------------\n\nfigma.showUI(\n    `<html><body style=\"margin:8px;font:12px ui-monospace,monospace\">\n<div id=out style=\"white-space:pre;max-width:380px\"></div>\n<button id=ok>Apply changes</button>\n<script>\n  const out=document.getElementById('out');\n  const log=(m)=>out.textContent+=m+\"\\\\n\";\n  onmessage=(e)=>{const msg=e.data.pluginMessage; if(msg?.type==='log') log(msg.text); };\n  document.getElementById('ok').onclick=()=>parent.postMessage({pluginMessage:{type:'apply-confirm'}},'*');\n</script></body></html>`,\n    { width: 420, height: 140 }\n);\n\n// -------------------- Communications --------------------\nfigma.ui.onmessage = async (msg) => {\n    if (msg?.type !== \"apply-json\") return;\n\n    try {\n        const raw = msg.text;\n        const parsed = typeof raw === \"string\" ? JSON.parse(raw) : raw;\n        const jsonfile = parseLoadedFile(parsed);\n\n        applyMeta(jsonfile.meta);\n        await applyVariables(jsonfile.variables);\n        await applyNodes(jsonfile.nodes);\n\n        ok(\"Changes applied\");\n    } catch (e) {\n        err(\"apply-json failed: \" + String((e as any)?.message ?? e));\n    }\n};\n\n// -------------------- Pipeline --------------------\n\n    async function applyJSONFile(jsonfile: { schema:any; meta:any; variables:any; nodes:any; }) {\n        applyMeta(jsonfile.meta);\n        await applyVariables(jsonfile.variables);\n        await applyNodes(jsonfile.nodes);\n    }\n\n// -------------------- Parsing / Normalization --------------------\n\n    function parseLoadedFile(obj: any) {\n        if (!obj || typeof obj !== \"object\") throw new Error(\"JSON must be an object\");\n        return {\n            schema: obj[\"$schema\"] || null,\n            meta: obj.meta || {},\n            variables: obj.variables || { collectionsCount: 0, collections: [] },\n            nodes: obj.nodes || null\n        };\n    }\n\n        // -------------------- Meta --------------------\n\n        function applyMeta(meta: any = {}) {\n            try {\n                // store what we can at document scope\n                if (meta.fileName) figma.root.setPluginData(\"yy_desiredFileName\", String(meta.fileName)); // cannot actually rename file\n                if (meta.scanId)   figma.root.setPluginData(\"yy_scanId\",       String(meta.scanId));\n                if (meta.pageName) figma.root.setPluginData(\"yy_pageName\",     String(meta.pageName));\n                if (meta.author)   figma.root.setPluginData(\"yy_author\",       String(meta.author));\n                if (meta.version)  figma.root.setPluginData(\"yy_version\",      String(meta.version));\n\n                // optional shared plugin data (namespaced) for team-wide visibility\n                try {\n                    const NS = \"yy\";\n                    Object.entries(meta).forEach(([k,v]) => { if (v != null) figma.root.setSharedPluginData(NS, k, String(v)); });\n                } catch {}\n\n                const desired = figma.root.getPluginData(\"yy_desiredFileName\");\n                if (desired) ok(`Please rename this file to: ${desired} (plugins can’t rename files)`);\n                log(\"Meta saved: \" + JSON.stringify({ fileName: meta.fileName, scanId: meta.scanId, pageName: meta.pageName, author: meta.author, version: meta.version }));\n            } catch (e) { err(\"applyMeta: \" + String(e)); }\n        }\n\n        // -------------------- Variables (collections only, correct API) --------------------\n        // Note: variable APIs differ between plugin runtime versions. We feature-detect and keep things safe.\n\n            async function applyVariables(variables: any = { collectionsCount: 0, collections: [] }) {\n                try {\n                    const list = Array.isArray(variables?.collections) ? variables.collections : [];\n                    if (list.length === 0 || !figma.variables) { log(\"No variable collections to apply or API unavailable\"); return; }\n\n                    const existing = await figma.variables.getLocalVariableCollectionsAsync();\n                    const byName = new Map(existing.map(c => [c.name, c]));\n                    for (const c of list) {\n                        const name = (c?.name ?? \"\").trim(); if (!name) { log(\"Skip unnamed collection\"); continue; }\n                        if (byName.has(name)) { log(`Collection exists: \"${name}\"`); continue; }\n                        const created = figma.variables.createVariableCollection(name); // ← correct method\n                        log(`Created collection: \"${name}\" (${created.id})`);\n                        // (keep alpha scope: not creating variables/modes yet)\n                    }\n                } catch (e) { err(\"applyVariables: \" + String(e)); }\n            }\n\n        // -------------------- Nodes --------------------\n        async function applyNodes(nodes: any) {\n            if (!nodes) return log(\"No changes found\");\n            const arr = Array.isArray(nodes) ? nodes : [nodes];\n\n            for (const n of arr) {\n                const t = n?.type || n?.kind; // tolerate either field\n                switch (t) {\n                    case \"frame-snapshot\":\n                    case undefined: // allow minimal entries that just have id/size/absPos\n                        // inline frame handler (replaces applyFrameSnapshot)\n                    {\n                        const id = n?.id; if (!id) { log(\"frame-snapshot missing id\"); break; }\n                        const node = figma.getNodeById(id); if (!node) { log(`Node ${id} not found`); break; }\n                        if (node.type !== \"FRAME\") { log(`Node ${id} not a FRAME — skip`); break; }\n\n                        try {\n                            const f = node as FrameNode;\n                            const p = n.absPos, s = n.size;\n                            if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) { f.x = p.x; f.y = p.y; log(`pos → ${p.x},${p.y}`); }\n                            if (s && Number.isFinite(s.w) && Number.isFinite(s.h)) { f.resize(s.w, s.h); log(`size → ${s.w}×${s.h}`); }\n                            ok(`Frame updated: ${f.name}`);\n                        } catch (e) { err(\"frame update: \" + String(e)); }\n                    }\n                        break;\n\n                    // ready for later, still inline if you want minimal footprint:\n                    case \"text-style\":\n                        // TODO: apply text props directly here (font, size, lineHeight, fills, etc.)\n                        log(`(todo) text-style change for ${n.id || n.name || \"node\"}`);\n                        break;\n\n                    case \"prototype-link\":\n                        // TODO: set prototype interactions here (requires building Interaction/Navigation objects)\n                        log(`(todo) prototype-link change for ${n.id || n.name || \"node\"}`);\n                        break;\n\n                    default:\n                        log(`Unknown node type: ${t}`);\n                }\n    }\n}\n\n// ready\nlog(\"YY MakeChanges ready\");\nfigma.notify(\"YY Make Changes plugin ready\");\n"
    },
    {
      "name": "manifest.json",
      "type": "file",
      "content": "{\n  \"name\": \"YY Figma Assistant — Implement\",\n  \"id\": \"yyfa-changes\",\n  \"api\": \"1.0.0\",\n  \"editorType\": [\"figma\"],\n  \"main\": \"main-changes.js\"\n}\n"
    },
    {
      "name": "package.json",
      "type": "file",
      "content": "{\n  \"scripts\": {\n    \"dev\": \"esbuild main-implement.ts --outfile=main-implement.js --format=cjs --platform=browser --target=es2018\"\n  }\n}"
    }
  ]
}